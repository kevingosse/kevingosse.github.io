<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Switching back to the UI thread in WPF/UWP, in modern C#",
  
  "datePublished": "2020-02-28T00:00:00Z",
  "dateModified": "2020-02-28T00:00:00Z",
  "author": {
    "@type": "Person",
    "name":  null ,
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/kevingosse.github.io\/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "minidump.net",
    
  },
  "description": "It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.\nSo what is the problem, to begin with?\nA quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.121.1 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="">
<meta name="keywords" content="">
<meta name="description" content="It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.
So what is the problem, to begin with?
A quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.">


<meta property="og:description" content="It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.
So what is the problem, to begin with?
A quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.">
<meta property="og:type" content="article">
<meta property="og:title" content="Switching back to the UI thread in WPF/UWP, in modern C#">
<meta name="twitter:title" content="Switching back to the UI thread in WPF/UWP, in modern C#">
<meta property="og:url" content="https://kevingosse.github.io/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e/">
<meta property="twitter:url" content="https://kevingosse.github.io/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e/">
<meta property="og:site_name" content="minidump.net">
<meta property="og:description" content="It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.
So what is the problem, to begin with?
A quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.">
<meta name="twitter:description" content="It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.
So what is the problem, to begin with?
A quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2020-02-28T00:00:00">
  
  
    <meta property="article:modified_time" content="2020-02-28T00:00:00">
  
  
  
  
    
      <meta property="article:tag" content="dotnet">
    
      <meta property="article:tag" content="wpf">
    
      <meta property="article:tag" content="uwp">
    
      <meta property="article:tag" content="software-development">
    
      <meta property="article:tag" content="async">
    
  


<meta name="twitter:card" content="summary">












    <title>Switching back to the UI thread in WPF/UWP, in modern C#</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="https://kevingosse.github.io/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://kevingosse.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/" aria-label="Go to homepage">minidump.net</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories" title="Categories">
    
      <i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/kookiz" target="_blank" rel="noopener" title="Twitter">
    
      <i class="sidebar-button-icon fab fa-lg fa-twitter" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/kevingosse" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaIn
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title">
      Switching back to the UI thread in WPF/UWP, in modern C#
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2020-02-28T00:00:00Z">
        
  
  
  
  
    February 28 2020
  

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <p>It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.</p>
<p>So what is the problem, to begin with?</p>
<h1 id="a-quick-reminder">A quick reminder</h1>
<p>In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread. This is done using <code>Control.Invoke</code> in WinForms and the dispatcher in WPF/UWP. The usage is pretty simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(UpdateControls));
</span></span></code></pre></div><p>(Note: In this article, I&rsquo;m going to focus on WPF, but everything can be translated to WinForms or UWP)</p>
<p>I&rsquo;ve often ended up in cases where it&rsquo;s not obvious in which thread I was. To handle those cases, I would encapsulate the &ldquo;switch to UI thread&rdquo; logic inside of the method that needs to update controls. To know whether I was already running in the UI thread or not, I would use the <code>Dispatcher.CheckAccess()</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> UpdateControls()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (!Dispatcher.CheckAccess())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// We&#39;re not in the UI thread, ask the dispatcher to call this same method in the UI thread, then exit</span>
</span></span><span style="display:flex;"><span>        Dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(UpdateControls));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We&#39;re in the UI thread, update the controls</span>
</span></span><span style="display:flex;"><span>    TextTime.Text = DateTime.Now.ToLongTimeString();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I really like it because I feel like it provides better separation of concerns, and I can call any method without worrying whether that method should run on the UI thread or not.</p>
<p>I&rsquo;ve mostly stopped developing desktop apps before tasks and async programming became mainstream. Nowadays, async/await provides another less-verbose solution thanks to custom awaiters. Today I would write something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task UpdateControls()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> Dispatcher.SwitchToUi();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TextTime.Text = DateTime.Now.ToLongTimeString();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To make that possible, I would declare <code>SwitchToUi</code> as an extension method on the dispatcher.
How do we do that? When implementing an awaiter, you need to provide two methods and one property:</p>
<ul>
<li>
<p><code>GetResult</code>: When called, you should synchronously wait for the operation to complete (if it&rsquo;s not completed already), and return the result (if any). Here, we&rsquo;ll leave the method empty because it does not make sense (we&rsquo;re switching contexts, we&rsquo;re not waiting on any operation)</p>
</li>
<li>
<p><code>IsCompleted</code>: This property indicates whether the async operation is completed. In our case, we consider it&rsquo;s completed if we&rsquo;re already running in the UI thread</p>
</li>
<li>
<p><code>OnCompleted</code>: This method will be called if <code>IsCompleted</code> returned false. It contains a callback that you need to call when the operation completes. For our purpose, we&rsquo;ll ask the dispatcher to invoke the callback on the UI thread.</p>
</li>
</ul>
<p>Put together, our helper looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DispatcherExtensions</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> SwitchToUiAwaitable SwitchToUi(<span style="color:#66d9ef">this</span> Dispatcher dispatcher)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> SwitchToUiAwaitable(dispatcher);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SwitchToUiAwaitable</span> : INotifyCompletion
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> Dispatcher _dispatcher;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> SwitchToUiAwaitable(Dispatcher dispatcher)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _dispatcher = dispatcher;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> SwitchToUiAwaitable GetAwaiter()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> GetResult()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsCompleted =&gt; _dispatcher.CheckAccess();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> OnCompleted(Action continuation)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _dispatcher.BeginInvoke(continuation);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a trick that has been documented in various forms, for instance <a href="https://thomaslevesque.com/2015/11/11/explicitly-switch-to-the-ui-thread-in-an-async-method/">on the blog of Thomas Levesque</a>.</p>
<h1 id="ok-i-knew-all-of-that-already">OK I knew all of that already</h1>
<p>Now things start to become interesting. A few days ago, I was playing with async method builders and custom task types <a href="https://twitter.com/KooKiz/status/1232599451279200262">as part of a joke</a>. A few hours later, I saw a question on StackOverflow about switching to the UI threadâ€¦ And everything clicked together. What we used is <code>AsyncMethodBuilder</code> to fill the same use-case as before but in a less verbose way?</p>
<p><code>AsyncMethodBuilder</code> is an API that allows you to returns custom task types in async methods. It&rsquo;s how <code>ValueTask</code> are implemented. The API gives you control over how calls are awaited inside of the method, but also when and on what thread the async method starts executing. That&rsquo;s what we&rsquo;re going to take advantage of.</p>
<p>How would that work? First, we need to declare a custom task type. We want to keep it simple, so we&rsquo;ll just make a wrapper around a <code>TaskCompletionSource</code>. We will also declare an implicit cast operator to <code>Task</code>, so that it can be used seamlessly with other APIs.
We also add the <code>AsyncMethodBuilder</code> attribute, which tells the compiler what method builder to use when an async method returns this type of task. In our case, we&rsquo;ll name our method builder <code>UiTaskMethodBuilder</code>.</p>
<p>Note: If you&rsquo;re running on .net framework, you need to reference the <a href="https://www.nuget.org/packages/System.Threading.Tasks.Extensions/">System.Threading.Tasks.Extensions</a> nuget package to use the <code>AsyncMethodBuilder</code> attribute.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[AsyncMethodBuilder(typeof(UiTaskMethodBuilder))]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UiTask</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">internal</span> TaskCompletionSource&lt;<span style="color:#66d9ef">object</span>&gt; Promise { <span style="color:#66d9ef">get</span>; } = <span style="color:#66d9ef">new</span> TaskCompletionSource&lt;<span style="color:#66d9ef">object</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Task AsTask() =&gt; Promise.Task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TaskAwaiter&lt;<span style="color:#66d9ef">object</span>&gt; GetAwaiter()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Promise.Task.GetAwaiter();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">implicit</span> <span style="color:#66d9ef">operator</span> Task(UiTask task) =&gt; task.AsTask();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For the method builder, there are a few methods we have to implement (it&rsquo;s all duck-typing, no interface to guide us):</p>
<ul>
<li><code>Start</code>: As the name indicates, this is called at the beginning of the async method. We are given an instance of the async state machine and are expected to call <code>MoveNext</code> when we&rsquo;re ready to start the execution. In our implementation, we&rsquo;re going to check whether we are running on the UI thread. If not, we switch to it before calling <code>MoveNext</code>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Start&lt;TStateMachine&gt;(<span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (!_dispatcher.CheckAccess())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(stateMachine.MoveNext));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        stateMachine.MoveNext();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><code>SetStateMachine</code>: This one is pretty obscure, I&rsquo;m not even sure when it&rsquo;s supposed to be called. We&rsquo;re not going to need it so we&rsquo;ll leave it empty.</p>
</li>
<li>
<p><code>Task</code>: This property exposes the instance of our custom UI task that will be returned by the async method</p>
</li>
<li>
<p><code>SetResult</code> and <code>SetException</code>: Either of these methods is called at the end of the async method, to set the result. We can simply map them to the <code>TaskCompletionSource</code> in our UI task:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> UiTask Task { <span style="color:#66d9ef">get</span>; } = <span style="color:#66d9ef">new</span> UiTask();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetResult()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Task.Promise.SetResult(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetException(Exception exception)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Task.Promise.SetException(exception);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>AwaitOnCompleted</code> and <code>AwaitUnsafeOnCompleted</code>: Those methods are called whenever there&rsquo;s an <code>await</code> call inside of the async method. <code>AwaitUnsafeOnCompleted</code> will be called it the awaiter implements <code>ICriticalNotifyCompletion</code>, and <code>AwaitOnCompleted</code> will be called otherwise. The difference between the two is only about how the execution context is flown. In our case, we&rsquo;re not going to worry about it. We call <code>OnComplete</code>/<code>UnsafeOnCompleted</code> on the awaiter, to know when it&rsquo;s complete, and we make sure to resume execution on the UI thread:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> TAwaiter awaiter,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> TAwaiter : INotifyCompletion
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    awaiter.OnCompleted(ResumeAfterAwait(stateMachine));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> TAwaiter awaiter,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> TAwaiter : ICriticalNotifyCompletion
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    awaiter.UnsafeOnCompleted(ResumeAfterAwait(stateMachine));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Action ResumeAfterAwait&lt;TStateMachine&gt;(TStateMachine stateMachine) <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> () =&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (!_dispatcher.CheckAccess())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(stateMachine.MoveNext));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            stateMachine.MoveNext();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Last but not least, we need to implement a static <code>Create</code> method, which will be called to instantiate our <code>UiTaskMethodBuilder</code> whenever an async method is invoked. Put together, our builder should look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UiTaskMethodBuilder</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> Dispatcher _dispatcher;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> UiTaskMethodBuilder(Dispatcher dispatcher)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _dispatcher = dispatcher;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Start&lt;TStateMachine&gt;(<span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (!_dispatcher.CheckAccess())
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(stateMachine.MoveNext));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            stateMachine.MoveNext();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> UiTaskMethodBuilder Create()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> UiTaskMethodBuilder(Application.Current.Dispatcher);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetStateMachine(IAsyncStateMachine stateMachine)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetResult()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Task.Promise.SetResult(<span style="color:#66d9ef">null</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetException(Exception exception)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Task.Promise.SetException(exception);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> UiTask Task { <span style="color:#66d9ef">get</span>; } = <span style="color:#66d9ef">new</span> UiTask();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ref</span> TAwaiter awaiter,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> TAwaiter : INotifyCompletion
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        awaiter.OnCompleted(ResumeAfterAwait(stateMachine));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ref</span> TAwaiter awaiter,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">ref</span> TStateMachine stateMachine)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> TAwaiter : ICriticalNotifyCompletion
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        awaiter.UnsafeOnCompleted(ResumeAfterAwait(stateMachine));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Action ResumeAfterAwait&lt;TStateMachine&gt;(TStateMachine stateMachine) <span style="color:#66d9ef">where</span> TStateMachine : IAsyncStateMachine
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> () =&gt;
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (!_dispatcher.CheckAccess())
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                _dispatcher.BeginInvoke(<span style="color:#66d9ef">new</span> Action(stateMachine.MoveNext));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                stateMachine.MoveNext();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we can go back to our <code>UpdateControls</code> method and remove the boilerplate code. Just by setting the return type to <code>UiTask</code>, we indicate our desire to run this method in the UI thread. If the method is invoked from a non-UI thread, the context will automatically change:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> UiTask UpdateControls()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    TextTime.Text = DateTime.Now.ToLongTimeString();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What do you think? Personally I really like how it indicates in the method signature that this call will run in the UI thread. If I was still implementing desktop applications, I would definitely use it. It adds some overhead and a few useless allocations, but for a non-server application it usually doesn&rsquo;t matter.</p>
<p>I believe it would be even better if we could do this with a custom attribute on <code>UpdateControls</code>, but it&rsquo;s not possible at the moment. It would however become possible <a href="https://github.com/dotnet/csharplang/issues/1407">if this proposition was implemented</a>.</p>

              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/dotnet/">dotnet</a>

  <a class="tag tag--primary tag--small" href="/tags/wpf/">wpf</a>

  <a class="tag tag--primary tag--small" href="/tags/uwp/">uwp</a>

  <a class="tag tag--primary tag--small" href="/tags/software-development/">software-development</a>

  <a class="tag tag--primary tag--small" href="/tags/async/">async</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114/" data-tooltip="Turning your training bike into a Speed remake" aria-label="NEXT: Turning your training bike into a Speed remake">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/another-way-to-use-your-debugging-tools-7e7f498d7a2b/" data-tooltip="Another way to use your debugging tools" aria-label="PREVIOUS: Another way to use your debugging tools">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#gitalk" aria-label="Leave a comment">
        <i class="fa fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            
  
    <div id="gitalk">
      <noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js" integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script type="text/javascript">
      (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
          document.getElementById('gitalk').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
          return;
        }
        new Gitalk({
          clientID: 'Iv1.8114b4896395b29e',
          clientSecret: '51d5de761d1fbcbfad430e94ebdecdf6765a20b5',
          repo: 'kevingosse.github.io',
          owner: 'kevingosse',
          admin: ['kevingosse'],
          id: 'f46cca68447480cdd9ea8f2828140142',
          ...{"distractionfreemode":false,"enablehotkey":true,"language":"en","pagerdirection":"first","perpage":10}
        }).render('gitalk')
      })()
    </script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2023 minidump.net. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114/" data-tooltip="Turning your training bike into a Speed remake" aria-label="NEXT: Turning your training bike into a Speed remake">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/another-way-to-use-your-debugging-tools-7e7f498d7a2b/" data-tooltip="Another way to use your debugging tools" aria-label="PREVIOUS: Another way to use your debugging tools">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
  
  
    <li class="post-action">
      <a class="post-action-btn btn btn--default" href="#gitalk" aria-label="Leave a comment">
        <i class="fa fa-comment"></i>
      </a>
    </li>
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      

    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
    <h4 id="about-card-name"></h4>
    
    
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://kevingosse.github.io/images/code.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://kevingosse.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

