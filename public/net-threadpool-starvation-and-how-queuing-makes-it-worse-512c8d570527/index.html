<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": ".NET ThreadPool starvation, and how queuing makes it worse",
  
  "image": "https://minidump.net/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-1.webp",
  
  "datePublished": "2020-04-27T00:00:00Z",
  "dateModified": "2020-04-27T00:00:00Z",
  "author": {
    "@type": "Person",
    "name": "Kevin Gosse",
    
    "image": "https://minidump.net/images/profile.png"
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/minidump.net\/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "minidump.net",
    
    "logo": {
      "@type": "ImageObject",
      "url": "https://minidump.net/images/profile.png"
    }
    
  },
  "description": "Explaining the ThreadPool starvation issue, and how it can be made worse by the way work-items are queued.",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.121.1 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="Kevin Gosse">
<meta name="keywords" content="">
<meta name="description" content="Explaining the ThreadPool starvation issue, and how it can be made worse by the way work-items are queued.">


<meta property="og:description" content="Explaining the ThreadPool starvation issue, and how it can be made worse by the way work-items are queued.">
<meta property="og:type" content="article">
<meta property="og:title" content=".NET ThreadPool starvation, and how queuing makes it worse">
<meta name="twitter:title" content=".NET ThreadPool starvation, and how queuing makes it worse">
<meta property="og:url" content="https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/">
<meta property="twitter:url" content="https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/">
<meta property="og:site_name" content="minidump.net">
<meta property="og:description" content="Explaining the ThreadPool starvation issue, and how it can be made worse by the way work-items are queued.">
<meta name="twitter:description" content="Explaining the ThreadPool starvation issue, and how it can be made worse by the way work-items are queued.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2020-04-27T00:00:00">
  
  
    <meta property="article:modified_time" content="2020-04-27T00:00:00">
  
  
  
  
    
      <meta property="article:tag" content="dotnet">
    
      <meta property="article:tag" content="performance">
    
      <meta property="article:tag" content="async">
    
  


<meta name="twitter:card" content="summary">

  <meta name="twitter:site" content="@kookiz">


  <meta name="twitter:creator" content="@kookiz">






  <meta property="og:image" content="https://minidump.net/images/profile.png">
  <meta property="twitter:image" content="https://minidump.net/images/profile.png">





  <meta property="og:image" content="https://minidump.net/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-1.webp">
  <meta property="twitter:image" content="https://minidump.net/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-1.webp">


    <title>.NET ThreadPool starvation, and how queuing makes it worse</title>

    
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    

    

    <link rel="canonical" href="https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://minidump.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MQCXFBVCCM"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-MQCXFBVCCM', { 'anonymize_ip': false });
}
</script>

    
    <script>
    (function(h,o,u,n,d) {
      h=h[d]=h[d]||{q:[],onReady:function(c){h.q.push(c)}}
      d=o.createElement(u);d.async=1;d.src=n
      n=o.getElementsByTagName(u)[0];n.parentNode.insertBefore(d,n)
    })(window,document,'script','https://www.datadoghq-browser-agent.com/us1/v5/datadog-rum.js','DD_RUM')
    window.DD_RUM.onReady(function() {
      window.DD_RUM.init({
        clientToken: 'pubabeb7320d5ecb81f3b14a17c35c1a3de',
        applicationId: '78b5d24e-77d4-4bba-ae37-5a46f7386b95',
        site: 'datadoghq.com',
        service: 'minidump.net',
        env: 'kevin',
        sessionSampleRate: 100,
        sessionReplaySampleRate: 20,
        trackUserInteractions: true,
        trackResources: true,
        trackLongTasks: true,
        defaultPrivacyLevel: 'mask-user-input',
      });
    })
</script>
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/" aria-label="Go to homepage">minidump.net</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Kevin Gosse</h4>
        
          <h5 class="sidebar-profile-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/kookiz" target="_blank" rel="noopener" title="Twitter">
    
      <i class="sidebar-button-icon fab fa-lg fa-twitter" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/kevingosse" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.buymeacoffee.com/kevingosse" target="_blank" rel="noopener" title="Buy me a coffee">
    
      <i class="sidebar-button-icon fas fa-lg fa-coffee" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Buy me a coffee</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaIn
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title">
      .NET ThreadPool starvation, and how queuing makes it worse
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2020-04-27T00:00:00Z">
        
  
  
  
  
    April 27 2020
  

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <p>There has been plenty of talk about ThreadPool starvation in .NET:</p>
<ul>
<li>
<p><a href="https://docs.microsoft.com/en-us/archive/blogs/vancem/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall?WT.mc_id=DT-MVP-5003493">https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/</a></p>
</li>
<li>
<p><a href="https://devblogs.microsoft.com/devopsservice/?p=17665&amp;WT.mc_id=DT-MVP-5003493">https://blogs.msdn.microsoft.com/vsoservice/?p=17665</a></p>
</li>
<li>
<p>Or even on the Criteo&rsquo;s blog: <a href="http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/">http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/</a></p>
</li>
</ul>
<p>What is it about? This is one of the numerous ways asynchronous code can break if you wait synchronously on a task.</p>
<p>To illustrate that, consider a web server that would execute this code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// ProcessRequest is called for every new request</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ProcessRequest()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    DoSomethingAsync().Wait();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You start an asynchronous operation (<code>DoSomethingAsync</code>) then block the current thread. At some point, the asynchronous operation will need a thread to finish executing, so it&rsquo;ll ask the ThreadPool for a new one. You end up using two threads for an operation that could be done with just one: one waiting actively on the Wait() method call and another one performing the continuation. In most cases this is fine. But it can become a problem if you deal with a burst of requests:</p>
<ul>
<li>
<p>Request 1 arrives at the server. <code>ProcessRequest</code> is called from a ThreadPool thread. It starts the asynchronous operation then waits on it</p>
</li>
<li>
<p>Requests 2, 3, 4, and 5 arrive at the server</p>
</li>
<li>
<p>The asynchronous operation completes and its continuation is enqueued to the ThreadPool</p>
</li>
<li>
<p>In the meantime, since 4 requests have arrived, 4 calls to <code>ProcessRequest</code> have been enqueued before your continuation</p>
</li>
<li>
<p>Each of those requests will, in turn, start an asynchronous operation and block their ThreadPool thread</p>
</li>
</ul>
<p>Combined with the fact that the ThreadPool grows very slowly (one thread per second or so), it&rsquo;s easy to understand how a burst of requests can push a system into a situation of thread starvation. But there&rsquo;s something missing in the picture: while the burst could temporarily lock the system unless the workload is continuously increasing, the ThreadPool should be capable of growing enough to eventually recover.</p>
<p>Yet, it does not fit what we observed on our own servers. We usually restart our instances as soon as starvation happens, but in one case we didn&rsquo;t. The ThreadPool grew until its hardcoded limit (32767 threads), and the system never recovered:</p>


 
  
  
  
  
    
  
    
      
    
  

<div class="figure center" >
  
    <a class="fancybox" href="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-1.webp" data-fancybox="">
  
    <img class="fig-img" src="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-1.webp" >
  
    </a>
  
  
</div>

<p>If you do the math, 32767 threads should be more than enough to handle the 1000–2000 QPS that our servers process, even if every request required 10 threads!</p>
<p>It seems there&rsquo;s something else going on.</p>
<h1 id="the-part-where-things-get-worse">The part where things get worse</h1>
<p>Let&rsquo;s consider the following code. Take a minute to guess what will happen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> Starvation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Console.WriteLine(Environment.ProcessorCount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ThreadPool.SetMinThreads(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Factory.StartNew(
</span></span><span style="display:flex;"><span>                Producer,
</span></span><span style="display:flex;"><span>                TaskCreationOptions.None);
</span></span><span style="display:flex;"><span>            Console.ReadLine();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Producer()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Process();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task Process()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">await</span> Task.Yield();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> tcs = <span style="color:#66d9ef">new</span> TaskCompletionSource&lt;<span style="color:#66d9ef">bool</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Run(() =&gt;
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>                tcs.SetResult(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tcs.Task.Wait();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">&#34;Ended - &#34;</span> + DateTime.Now.ToLongTimeString());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Producer enqueues 5 calls to Process every second. In Process, we yield to avoid blocking the caller, then we start a task that will wait 1 second and wait for it. In total, we start 5 tasks per second and each of those tasks will need an additional task. So we need 10 threads to absorb the constant workload. The ThreadPool is manually configured to start with 8 threads, so we are 2 threads short. My expectations are that the program will struggle for 2 seconds until the ThreadPool grows to absorb the workload. Then it needs to grow a bit further to process the additional work-items that we enqueued during the 2 seconds. After a few seconds, the situation will stabilize.</p>
<p>But if you run the program, you&rsquo;ll see that it managed to display &ldquo;Ended&rdquo; a few times in the console, then nothing happens anymore:</p>


 
  
  
  
  
    
  
    
      
    
  

<div class="figure center" >
  
    <a class="fancybox" href="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-2.webp" data-fancybox="">
  
    <img class="fig-img" src="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-2.webp" >
  
    </a>
  
  
</div>

<p><em>Note that this code assumes that <code>Environment.ProcessorCount</code> is lower or equal to 8 on your machine. If it&rsquo;s bigger, then the ThreadPool will start with more thread available, and you need to lower the delay of the <code>Thread.Sleep</code> in <code>Producer()</code> to set the same conditions.</em></p>
<p>Looking at the task manager, we can see that CPU usage is 0 and the number of threads is growing at about one per second:</p>


 
  
  
  
  
    
  
    
      
    
  

<div class="figure center" >
  
    <a class="fancybox" href="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-3.webp" data-fancybox="">
  
    <img class="fig-img" src="/images/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527-3.webp" >
  
    </a>
  
  
</div>

<p>Here I&rsquo;ve let it run for a while and got to a whopping 989 threads, yet still nothing is happening! Even though 10 threads should be enough to handle the workload. So what&rsquo;s going on?</p>
<p>Every bit is important in that code. For instance, if we remove <code>Task.Yield</code> and manually start new tasks instead in <code>Producer</code> (the comments indicate the changes):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> Starvation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Console.WriteLine(Environment.ProcessorCount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ThreadPool.SetMinThreads(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Factory.StartNew(
</span></span><span style="display:flex;"><span>                Producer,
</span></span><span style="display:flex;"><span>                TaskCreationOptions.None);
</span></span><span style="display:flex;"><span>            Console.ReadLine();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Producer()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Creating a new task instead of just calling Process</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Needed to avoid blocking the loop since we removed the Task.Yield</span>
</span></span><span style="display:flex;"><span>                Task.Factory.StartNew(Process);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task Process()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Removed the Task.Yield</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> tcs = <span style="color:#66d9ef">new</span> TaskCompletionSource&lt;<span style="color:#66d9ef">bool</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Run(() =&gt;
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>                tcs.SetResult(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tcs.Task.Wait();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">&#34;Ended - &#34;</span> + DateTime.Now.ToLongTimeString());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then we get the predicted behavior! The application struggles a bit at first, until the ThreadPool grows enough. Then we have a steady stream of messages, and the number of threads is stable (29 in my case).</p>
<p>What if we take that working code but start <code>Producer</code> in its own thread?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> Starvation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Console.WriteLine(Environment.ProcessorCount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ThreadPool.SetMinThreads(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Factory.StartNew(
</span></span><span style="display:flex;"><span>                Producer,
</span></span><span style="display:flex;"><span>                TaskCreationOptions.LongRunning); <span style="color:#75715e">// Start in a dedicated thread</span>
</span></span><span style="display:flex;"><span>            Console.ReadLine();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Producer()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Process();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task Process()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">await</span> Task.Yield();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> tcs = <span style="color:#66d9ef">new</span> TaskCompletionSource&lt;<span style="color:#66d9ef">bool</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Run(() =&gt;
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>                tcs.SetResult(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tcs.Task.Wait();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">&#34;Ended - &#34;</span> + DateTime.Now.ToLongTimeString());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This frees one thread from the ThreadPool, so we should expect it to work slightly better. Yet, we end up with the first case: the application displays a few messages before locking up, and the number of threads grows indefinitely.</p>
<p>Let&rsquo;s put <code>Producer</code> back to a ThreadPool thread, but use the <code>PreferFairness</code> flag when starting the <code>Process</code> tasks:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> System.Threading.Tasks;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> Starvation
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Program</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Console.WriteLine(Environment.ProcessorCount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ThreadPool.SetMinThreads(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Factory.StartNew(
</span></span><span style="display:flex;"><span>                Producer,
</span></span><span style="display:flex;"><span>                TaskCreationOptions.None);
</span></span><span style="display:flex;"><span>            Console.ReadLine();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Producer()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Task.Factory.StartNew(Process, TaskCreationOptions.PreferFairness); <span style="color:#75715e">// Using PreferFairness</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">200</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task Process()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> tcs = <span style="color:#66d9ef">new</span> TaskCompletionSource&lt;<span style="color:#66d9ef">bool</span>&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Task.Run(() =&gt;
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Thread.Sleep(<span style="color:#ae81ff">1000</span>);
</span></span><span style="display:flex;"><span>                tcs.SetResult(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            tcs.Task.Wait();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">&#34;Ended - &#34;</span> + DateTime.Now.ToLongTimeString());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then once again we end up with the first situation: the application locks up, and the number of threads increases indefinitely.</p>
<p>So, what is really going on?</p>
<h1 id="the-threadpool-queuing-algorithm">The ThreadPool queuing algorithm</h1>
<p>To understand what&rsquo;s happening, we need to dig into the internals of the ThreadPool. More specifically, in the way, the work-items are queued.</p>
<p>There are a few articles out there explaining how the ThreadPool queuing works (<a href="http://www.danielmoth.com/Blog/New-And-Improved-CLR-4-Thread-Pool-Engine.aspx">http://www.danielmoth.com/Blog/New-And-Improved-CLR-4-Thread-Pool-Engine.aspx</a>). In a nutshell, the important part is that the ThreadPool has multiple queues. For N threads in the ThreadPool, there are N+1 queues: one local queue for each thread, and one global queue. The rules for picking in which queue your item will go are simple:</p>
<p>The item will be enqueued to the global queue:</p>
<ul>
<li>
<p>If the thread that enqueues the item is not a ThreadPool thread</p>
</li>
<li>
<p>If it uses <code>ThreadPool.QueueUserWorkItem</code> or <code>ThreadPool.UnsafeQueueUserWorkItem</code></p>
</li>
<li>
<p>If it uses <code>Task.Factory.StartNew</code> with the <code>TaskCreationOptions.PreferFairness</code> flag</p>
</li>
<li>
<p>If it uses <code>Task.Yield</code> on the default task scheduler</p>
</li>
</ul>
<p>In pretty much all other cases, the item will be enqueued to the thread&rsquo;s local queue.</p>
<p>How are the items dequeued? Whenever a ThreadPool thread is free, it will start looking into its local queue, and dequeue items in LIFO order. If the local queue is empty, then the thread will look into the global queue and dequeue in the FIFO order. If the global queue is also empty, then the thread will look into the local queues of other threads and dequeue in FIFO order (to reduce the contention with the owner of the queue, which dequeues in LIFO order).</p>
<h3 id="how-does-that-impact-us-lets-go-back-to-our-faulty-code">How does that impact us? Let&rsquo;s go back to our faulty code.</h3>
<p>In all the variations of the code, the <code>Thread.Sleep(1000)</code> is enqueued in a local queue, because <code>Process</code> is always executed in a ThreadPool thread. But in some cases we enqueue <code>Process</code> in the global queue and in others in the local queues:</p>
<ul>
<li>
<p>In the first version of the code, we use <code>Task.Yield</code>, which queues to the global queue</p>
</li>
<li>
<p>In the second version, we use <code>Task.Factory.StartNew</code>, which queues to the local queue</p>
</li>
<li>
<p>In the third version, we change the <code>Producer</code> thread to not use the ThreadPool, so <code>Task.Factory.StartNew</code> enqueues to the global queue</p>
</li>
<li>
<p>In the fourth version, <code>Producer</code> is a ThreadPool thread again but we use <code>TaskCreationOptions.PreferFairness</code> when enqueuing <code>Process</code>, thus using the global queue again</p>
</li>
</ul>
<p>We can see that the only version that worked was the one not using the global queue. From there, it&rsquo;s just a matter of connecting the dots:</p>
<ul>
<li>
<p>Initial condition: we put our system in a state where the ThreadPool is starved (i.e. all the threads are busy)</p>
</li>
<li>
<p>We enqueue 5 items per second into the global queue</p>
</li>
<li>
<p>Each of those items, when executing, enqueues another item into the local queue and waits for it</p>
</li>
<li>
<p>When a new thread is spawned by the ThreadPool, that thread will first look into its own local queue which is empty (since it&rsquo;s newborn). Then it&rsquo;ll pick an item from the global queue</p>
</li>
<li>
<p>Since we enqueue into the global queue faster than the ThreadPool grows (5 items per second versus 1 thread per second), it&rsquo;s completely impossible for the system to recover. Because of the priority induced by the usage of the global queue, <strong>the more threads we add, the more pressure we put on the system</strong></p>
</li>
</ul>
<p>When using the local queue instead (second version of the code), the newborn threads will pick items from the other threads&rsquo; local queues since the global queue is empty. Therefore, <strong>new threads help alleviate the pressure on the system.</strong></p>
<h3 id="how-does-it-translate-to-a-real-world-scenario">How does it translate to a real-world scenario?</h3>
<p>Take the case of an HTTP-based service. The HTTP stack, whether it uses Windows&rsquo; http.sys or another API, is most likely native. When it forwards new requests to the .NET user code, it&rsquo;ll queue them in the ThreadPool. Those items will necessarily end up in the global queue since the native HTTP stack can&rsquo;t possibly use .NET ThreadPool threads. Then the user code relies on async/await, and very likely uses the local queues all the way. It means that in a situation of starvation, new threads spawned by the ThreadPool will process the new requests (enqueued in the global queue by the native code) rather than completing the ones already in the pipe (enqueued in the local queues). Therefore, <strong>we end up in the situation previously described where every new thread adds even more pressure to the system.</strong></p>
<p>Another situation where things can turn ugly is if the blocking code is running as part of the callback of a timer. Timer callbacks are enqueued into the global queue. I believe such a case can be found here (pay close attention to the <code>TimerQueueTimer.Fire</code> call at the beginning of the callstack for the 1202 threads shown): <a href="https://devblogs.microsoft.com/devopsservice/?p=17665&amp;WT.mc_id=DT-MVP-5003493">https://blogs.msdn.microsoft.com/vsoservice/?p=17665</a>.</p>
<h1 id="what-can-we-do-about-that">What can we do about that?</h1>
<p>From a user-code perspective, unfortunately not much. Of course, in an ideal world, we would use non-blocking code and never end up in a ThreadPool starvation situation. Using a dedicated pool of threads around the blocking calls can help a lot, as you stop competing with the global queue for new threads. Having a back-pressure system is a good idea too. At Criteo we&rsquo;re experimenting with a back-pressure system that measures how long it takes for the ThreadPool to dequeue an item from a local queue. If it takes longer than a few configured threshold, then we stop processing incoming requests until the system recovers. So far it shows promising results.</p>
<p>From a BCL perspective, I believe we should treat the global queue as just another local queue. I can&rsquo;t really see a reason why it should be treated in priority compared to all other local queues. If we&rsquo;re afraid that the global queue would grow quicker than the other queues, we could put a weight on the random selection of the queue. It would probably require some adjustments, but this is worth exploring.</p>
<p><a href="https://labs.criteo.com/2018/10/net-threadpool-starvation-and-how-queuing-makes-it-worse/"><em>Article originally posted on Criteo Labs</em></a></p>

              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/dotnet/">dotnet</a>

  <a class="tag tag--primary tag--small" href="/tags/performance/">performance</a>

  <a class="tag tag--primary tag--small" href="/tags/async/">async</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/performance-best-practices-in-c-b85a47bdd93a/" data-tooltip="Performance best practices in C#" aria-label="NEXT: Performance best practices in C#">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114/" data-tooltip="Turning your training bike into a Speed remake" aria-label="PREVIOUS: Turning your training bike into a Speed remake">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            

<link href="https://fonts.googleapis.com/css?family=Cookie&amp;display=swap" rel="stylesheet">
<div class="bmc-btn-container"><a class="bmc-btn" target="_blank" href="https://buymeacoffee.com/kevingosse">☕<span class="bmc-btn-text">Enjoyed the article? Buy me a coffee</span></a></div>

<style>
    .bmc-btn {
        min-width: 210px;
        color: #000000;
        background-color: #FFFFFF !important;
        height: 60px;
        border-radius: 12px;
        font-size: 28px;
        font-weight: Normal;
        border: none;
        line-height: 27px;
        text-decoration: none !important;
        display: inline-flex !important;
        justify-content: center;
        align-items: center;
        font-family: 'Cookie', cursive !important;
        -webkit-box-sizing: border-box !important;
        box-sizing: border-box !important;
    }

    .bmc-btn:hover, .bmc-btn:active, .bmc-btn:focus {
        text-decoration: none !important;
        cursor: pointer;
    }

    .bmc-btn-text {
        margin-left: 8px;
        display: inline-block;
        line-height: 0;
        width: 100%;
        flex-shrink: 0;
        font-family: [FONT] !important;
    }

    .logo-outline {
        fill: #000000;
    }

    .logo-coffee {
        fill: #ffffff;
    }</style>

  
<div id="utterances">
      <noscript>Please enable JavaScript to view the comments powered by Utterances.</noscript>
    </div>
<script src="https://utteranc.es/client.js"
        repo="kevingosse/kevingosse.github.io"
        issue-term="title"
        label="comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2024 Kevin Gosse. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/performance-best-practices-in-c-b85a47bdd93a/" data-tooltip="Performance best practices in C#" aria-label="NEXT: Performance best practices in C#">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114/" data-tooltip="Turning your training bike into a Speed remake" aria-label="PREVIOUS: Turning your training bike into a Speed remake">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      
<div id="share-options-bar" class="share-options-bar" data-behavior="2">
  <i id="btn-close-shareoptions" class="fa fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fminidump.net%2Fnet-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527%2F" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https%3A%2F%2Fminidump.net%2Fnet-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527%2F" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i><span>Share on Linkedin</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.reddit.com/submit?url=https%3A%2F%2Fminidump.net%2Fnet-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527%2F" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i><span>Share on Reddit</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fminidump.net%2Fnet-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527%2F" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i><span>Share on Hacker News</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>


    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Kevin Gosse</h4>
    
      <div id="about-card-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</div>
    
    
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://minidump.net/images/code.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://minidump.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

