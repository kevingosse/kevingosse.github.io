<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>performance on minidump.net</title>
    <link>https://minidump.net/tags/performance/</link>
    <description>Recent content in performance on minidump.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Sep 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://minidump.net/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Memory alignment of doubles in C#</title>
      <link>https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/</link>
      <pubDate>Sat, 30 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/</guid>
      <description>A while ago, I mentioned on Twitter an interesting quirk of objects in .NET: when running in 64 bits, objects are aligned on a 8-bytes boundary despite having a 32 bits header, and therefore 32 bits are &amp;ldquo;lost&amp;rdquo; before each object:&#xA;It bothers me so much that on #dotnet on 64-bit, 4 bytes are wasted for *every class instance* because objects are aligned on a 8 bytes boundary and the header has a fixed size of 4 bytes.</description>
    </item>
    <item>
      <title>SuppressGCTransition</title>
      <link>https://minidump.net/suppressgctransition-b9a8a774edbd/</link>
      <pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/suppressgctransition-b9a8a774edbd/</guid>
      <description>While working on the second edition of the Pro .NET Memory Management book, I did some research on the SuppressGCTransition attribute introduced in .NET 5, and figured it would make a nice complimentary article.&#xA;SuppressGCTransition is an attribute you can only apply on a method decorated with the DllImport attribute. It greatly reduces the overhead of the p/invoke, as illustrated with this benchmark:&#xA;public class SuppressGcTransitionBenchmark { [Benchmark(Baseline = true)] public int PInvoke() { return Increment(42); [DllImport(&amp;#34;NativeLib.</description>
    </item>
    <item>
      <title>Reading .NET performance counters without the PerfCounter API</title>
      <link>https://minidump.net/reading-net-performance-counters-without-the-perfcounter-api-aca5eab08874/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/reading-net-performance-counters-without-the-perfcounter-api-aca5eab08874/</guid>
      <description>Note: The code was originally written as part of my job at Datadog and published on the dd-trace-dotnet repository under Apache 2.0 license.&#xA;The excerpts of code in this article are therefore licensed under the same terms. Before using them, quoting them, or redistributing them, make sure to check the terms of the license and the notice.&#xA;The Datadog .NET tracer has a feature named &amp;ldquo;runtime metrics&amp;rdquo;. It collects technical metrics about the way your application behaves and publishes them to a dedicated dashboard, that you can use to diagnose your performance issues:</description>
    </item>
    <item>
      <title>Showing unresolved functions in PerfView</title>
      <link>https://minidump.net/showing-unresolved-functions-in-perfview-ab6cd899cb94/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/showing-unresolved-functions-in-perfview-ab6cd899cb94/</guid>
      <description>One thing that has bothered me quite a bit with PerfView is how it groups all unresolved frames under the same &amp;ldquo;?!?&amp;rdquo; name. I understand that it&amp;rsquo;s a way to reduce noise, but when trying to reduce the CPU usage of an application it can be unsettling.&#xA;Take the following example:&#xA;Here, &amp;ldquo;?!?&amp;rdquo; is presented as top offender, accounting for more than 7% of the total CPU usage. But I&amp;rsquo;m missing critical information to know whether I should consider it as a bottleneck or not.</description>
    </item>
    <item>
      <title>Performance best practices in C#</title>
      <link>https://minidump.net/performance-best-practices-in-c-b85a47bdd93a/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/performance-best-practices-in-c-b85a47bdd93a/</guid>
      <description>As I recently had to compile a list of best practices in C# for Criteo, I figured it would be nice to share it publicly. The goal of this article is to provide a non-exhaustive list of code patterns to avoid, either because they&amp;rsquo;re risky or because they perform poorly. The list may seem a bit random because it&amp;rsquo;s out of context, but all the items have been spotted in our code at some point and have caused production issues.</description>
    </item>
    <item>
      <title>.NET ThreadPool starvation, and how queuing makes it worse</title>
      <link>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</guid>
      <description>There has been plenty of talk about ThreadPool starvation in .NET:&#xA;https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/&#xA;https://blogs.msdn.microsoft.com/vsoservice/?p=17665&#xA;Or even on the Criteo&amp;rsquo;s blog: http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/&#xA;What is it about? This is one of the numerous ways asynchronous code can break if you wait synchronously on a task.&#xA;To illustrate that, consider a web server that would execute this code:&#xA;/// ProcessRequest is called for every new request public void ProcessRequest() { DoSomethingAsync().Wait(); } You start an asynchronous operation (DoSomethingAsync) then block the current thread.</description>
    </item>
    <item>
      <title>Optimizing the WinDbg DML parser</title>
      <link>https://minidump.net/optimizing-the-windbg-dml-parser-9f64419f9/</link>
      <pubDate>Thu, 03 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/optimizing-the-windbg-dml-parser-9f64419f9/</guid>
      <description>One of my pet project is writing a custom command window for WinDbg. When testing that custom command window with big outputs, I quickly noticed that the performance was unacceptable: the first few lines would be displayed smoothly, then the application would become slower and slower until almost freezing. I therefore decided to optimize my implementation: tweaking the rendering code, batching updates, … But no matter what I did, the performance was still bad.</description>
    </item>
  </channel>
</rss>
