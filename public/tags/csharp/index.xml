<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp on minidump.net</title>
    <link>https://minidump.net/tags/csharp/</link>
    <description>Recent content in csharp on minidump.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Jun 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://minidump.net/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Writing a .NET profiler in C# — Part 4</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-4-c54df903b9ce/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-4-c54df903b9ce/</guid>
      <description>In part 1, we saw how NativeAOT can allow us to write a profiler in C#, and how to expose a fake COM object to use the profiling API. In part 2, we refined the solution to use instance methods instead of static methods. In part 3, we automated the process using a source generator. At this point, we have everything we need to expose an instance of ICorProfilerCallback. However, to write a profiler we also need to be able to call methods from ICorProfilerInfo, this will be the subject of this part.</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C#   — Part 3</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-3-7d2c59fc017f/</link>
      <pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-3-7d2c59fc017f/</guid>
      <description>In part 1, we saw how NativeAOT can allow us to write a profiler in C#, and how to expose a fake COM object to use the profiling API. In part 2, we refined the solution to use instance methods instead of static methods. Now that we know how to interact with the profiling API, we&amp;rsquo;re going to write a source generator to automatically generate the boilerplate code needed to implement the 70+ methods declared in the ICorProfilerCallback interface.</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C#  —  Part 2</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-2-8039da001e43/</link>
      <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-2-8039da001e43/</guid>
      <description>In the first part, we saw how to mimic the layout of a COM object, and use it to expose a fake instance of IClassFactory. It worked nicely, but our solution used static methods, so it wouldn&amp;rsquo;t be convenient to track the state of the objects whenever multiple instances are expected. It would be great if we could map our COM object to an actual instance of an object in .</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C# - Part 1</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-1-d3978aae9b12/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-1-d3978aae9b12/</guid>
      <description>.NET has a very powerful profiling API, that allows to closely monitor the runtime, dynamically rewrite methods during execution, walk the callstack of threads at arbitrary points in time, and much more. However, the entry cost to learn how to use that API is quite high. The first reason is that many features require a good knowledge of how the .NET metadata system works. The other reason is that all the documentation and examples are written in C++.</description>
    </item>
    <item>
      <title>AccessViolation in ObjectNative::IsLockHeld (part 2 of 2)</title>
      <link>https://minidump.net/accessviolation-in-objectnative-islockheld-part-2-of-2-a703e484113c/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/accessviolation-in-objectnative-islockheld-part-2-of-2-a703e484113c/</guid>
      <description>This is the second part of an investigation where I tried to understand why an application was randomly crashing with an AccessViolationException.&#xA;If you haven&amp;rsquo;t read it, you can find part 1 of the investigation here.&#xA;As a reminder, here is what we uncovered so far:&#xA;The server runs Orchard, with the Datadog .NET tracer, and crashes about once or twice per day&#xA;The crash dump indicated an access violation in method clr!</description>
    </item>
  </channel>
</rss>
