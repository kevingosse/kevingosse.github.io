<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp on minidump.net</title>
    <link>https://minidump.net/tags/csharp/</link>
    <description>Recent content in csharp on minidump.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Jun 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://minidump.net/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Writing a .NET profiler in C# — Part 4</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-4-c54df903b9ce/</link>
      <pubDate>Sat, 10 Jun 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-4-c54df903b9ce/</guid>
      <description>In part 1, we saw how NativeAOT can allow us to write a profiler in C#, and how to expose a fake COM object to use the profiling API. In part 2, we refined the solution to use instance methods instead of static methods. In part 3, we automated the process using a source generator. At this point, we have everything we need to expose an instance of ICorProfilerCallback. However, to write a profiler we also need to be able to call methods from ICorProfilerInfo, this will be the subject of this part.</description>
    </item>
    <item>
      <title>VerificationException in .NET Framework when using structs</title>
      <link>https://minidump.net/verificationexception-in-net-framework-when-using-structs-6269eb3df448/</link>
      <pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/verificationexception-in-net-framework-when-using-structs-6269eb3df448/</guid>
      <description>Consider the following code:&#xA;private static readonly ReadonlyStruct Struct; public static void Read() { Console.WriteLine(Struct.Value); } public struct ReadonlyStruct { public ReadonlyStruct(int value) { Value = value; } public int Value; } This looks pretty straightforward, right? We store a struct in a readonly field, and read it.&#xA;Yet, what happens if we try to run this program in .NET Framework under partial trust?&#xA;static void Main(string[] args) { var permissionSet = new PermissionSet(PermissionState.</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C#   — Part 3</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-3-7d2c59fc017f/</link>
      <pubDate>Fri, 03 Mar 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-3-7d2c59fc017f/</guid>
      <description>In part 1, we saw how NativeAOT can allow us to write a profiler in C#, and how to expose a fake COM object to use the profiling API. In part 2, we refined the solution to use instance methods instead of static methods. Now that we know how to interact with the profiling API, we&amp;rsquo;re going to write a source generator to automatically generate the boilerplate code needed to implement the 70+ methods declared in the ICorProfilerCallback interface.</description>
    </item>
    <item>
      <title>Reading .NET performance counters without the PerfCounter API</title>
      <link>https://minidump.net/reading-net-performance-counters-without-the-perfcounter-api-aca5eab08874/</link>
      <pubDate>Sun, 12 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/reading-net-performance-counters-without-the-perfcounter-api-aca5eab08874/</guid>
      <description>Note: The code was originally written as part of my job at Datadog and published on the dd-trace-dotnet repository under Apache 2.0 license.&#xA;The excerpts of code in this article are therefore licensed under the same terms. Before using them, quoting them, or redistributing them, make sure to check the terms of the license and the notice.&#xA;The Datadog .NET tracer has a feature named &amp;ldquo;runtime metrics&amp;rdquo;. It collects technical metrics about the way your application behaves and publishes them to a dedicated dashboard, that you can use to diagnose your performance issues:</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C#  —  Part 2</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-2-8039da001e43/</link>
      <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-2-8039da001e43/</guid>
      <description>In the first part, we saw how to mimick the layout of a COM object, and use it to expose a fake instance of IClassFactory. It worked nicely, but our solution used static methods, so it wouldn&amp;rsquo;t be convenient to track the state of the objects whenever multiple instances are expected. It would be great if we could map our COM object to an actual instance of an object in .</description>
    </item>
    <item>
      <title>Using GC.KeepAlive in async methods</title>
      <link>https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/</link>
      <pubDate>Mon, 05 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/</guid>
      <description>[C#] Using GC.KeepAlive in async methods Can you figure out what&amp;rsquo;s wrong with this code?&#xA;var taskCompletionSource = new TaskCompletionSource(); MyDelegateType myDelegate = () =&amp;gt; taskCompletionSource.SetResult(); NativeMethods.MyNativeMethod(myDelegate); await taskCompletionSource.Task; GC.KeepAlive(myDelegate); It turns out that when running in an actual application, there is a probability that myDelegate will get collected despite the call to GC.KeepAlive.&#xA;This code was posted in an issue in the dotnet/runtime repository, and I followed it closely because I really couldn&amp;rsquo;t tell what the error was.</description>
    </item>
    <item>
      <title>Why function pointers can&#39;t be used on instance methods in C#</title>
      <link>https://minidump.net/c-why-function-pointers-cant-be-used-on-instance-methods-8a99fc99b040/</link>
      <pubDate>Tue, 26 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/c-why-function-pointers-cant-be-used-on-instance-methods-8a99fc99b040/</guid>
      <description>A few days ago, a github issue in the dotnet/runtime repository piqued my interest. To summarize, the author was wondering why their code wasn&amp;rsquo;t working as expected. Here is a simplified version:&#xA;public unsafe class Getter { private delegate*&amp;lt;Obj, SomeStruct&amp;gt; _functionPointer; public Getter(string propName) { var methodInfo = typeof(Obj).GetProperty(propName).GetGetMethod(); _functionPointer = (delegate*&amp;lt;Obj, SomeStruct&amp;gt;)methodInfo.MethodHandle.GetFunctionPointer(); } public SomeStruct GetFromFunctionPointer(Obj target) { var v = _functionPointer(target); return v; } } public struct SomeStruct { public int Value1; public int Value2; public int Value3; public int Value4; } public class Obj { public SomeStruct Property { get; set; } } class Program { static void Main(string[] args) { var obj = new Obj { Property = new SomeStruct { Value1 = 42 } }; var getter = new Getter(&amp;#34;Property&amp;#34;); Console.</description>
    </item>
    <item>
      <title>Writing a .NET profiler in C# - Part 1</title>
      <link>https://minidump.net/writing-a-net-profiler-in-c-part-1-d3978aae9b12/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-a-net-profiler-in-c-part-1-d3978aae9b12/</guid>
      <description>.NET has a very powerful profiling API, that allows to closely monitor the runtime, dynamically rewrite methods during execution, walk the callstack of threads at arbitrary points in time, and much more. However, the entry cost to learn how to use that API is quite high. The first reason is that many features require a good knowledge of how the .NET metadata system works. The other reason is that all the documentation and examples are written in C++.</description>
    </item>
    <item>
      <title>Reading AsyncLocal values from a memory dump</title>
      <link>https://minidump.net/reading-asynclocal-values-from-a-memory-dump-8be356a46b29/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/reading-asynclocal-values-from-a-memory-dump-8be356a46b29/</guid>
      <description>This article explains how AsyncLocal values are stored in .NET and how to retrieve them from a memory dump. Note that the code provided is written for .NET 5, but should be able to work for .NET Framework with minor modifications (the name of some internal fields have changed across versions).&#xA;Preparing the memory dump First thing first, we need to prepare the memory dump that will serve as example for the whole article.</description>
    </item>
    <item>
      <title>Analyze your memory dumps in C# with DynaMD</title>
      <link>https://minidump.net/analyze-your-memory-dumps-in-c-with-dynamd-8e4b110b9d3a/</link>
      <pubDate>Fri, 16 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/analyze-your-memory-dumps-in-c-with-dynamd-8e4b110b9d3a/</guid>
      <description>Whenever you need to analyze complex structures in a .NET memory dump, the WinDbg scripting API quickly shows its limits. In those cases, you can instead use the ClrMD library, that will give you everything you need to inspect the memory dump from C# code.&#xA;Not everything is perfect however, and sometimes I feel like the ClrMD syntax does not feel &amp;ldquo;natural&amp;rdquo; enough. To take one concrete example, for an investigation I had to retrieve the URLs of the pending HTTP requests in a memory dump.</description>
    </item>
    <item>
      <title>An unconventional way of investigating a NullReferenceException</title>
      <link>https://minidump.net/an-unconventional-way-of-investigating-a-nullreferenceexception-5628cca01d6a/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/an-unconventional-way-of-investigating-a-nullreferenceexception-5628cca01d6a/</guid>
      <description>The crash This one started when trying to understand why an integration test was failing, only on Linux with ARM64.&#xA;As I had no ARM64 dev environment available, I first tried adding more and more traces and let the test run in the CI, without much success.&#xA;Eventually, I realized this was leading nowhere, and took the time to setup an ARM64 VM to investigate further. After running the test with LLDB (see my previous article to learn how to fetch the symbols for the CLR), I found out that the process was raising two segmentations faults, and the second one caused the crash:</description>
    </item>
    <item>
      <title>AccessViolation in ObjectNative::IsLockHeld (part 2 of 2)</title>
      <link>https://minidump.net/accessviolation-in-objectnative-islockheld-part-2-of-2-a703e484113c/</link>
      <pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/accessviolation-in-objectnative-islockheld-part-2-of-2-a703e484113c/</guid>
      <description>This is the second part of an investigation where I tried to understand why an application was randomly crashing with an AccessViolationException.&#xA;If you haven&amp;rsquo;t read it, you can find part 1 of the investigation here.&#xA;As a reminder, here is what we uncovered so far:&#xA;The server runs Orchard, with the Datadog .NET tracer, and crashes about once or twice per day&#xA;The crash dump indicated an access violation in method clr!</description>
    </item>
    <item>
      <title>AccessViolation in ObjectNative::IsLockHeld (part 1 of 2)</title>
      <link>https://minidump.net/accessviolation-in-objectnative-islockheld-part-1-of-2-7fae4b839f9a/</link>
      <pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/accessviolation-in-objectnative-islockheld-part-1-of-2-7fae4b839f9a/</guid>
      <description>This is a two parts article. Part two is available here.&#xA;Symptoms To monitor the stability of the Datadog .NET tracer, we have a reliability environment where we continuously run mainstream applications such as Orchard. This story starts when, while preparing a release, we discovered that the latest version of our tracer was crashing the app with the message:&#xA;Application: w3wp.exe Framework Version: v4.0.30319 Description: The process was terminated due to an internal error in the .</description>
    </item>
    <item>
      <title>Investigating an InvalidProgramException from a memory dump (part 3 of 3)</title>
      <link>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-3-of-3-c1d912075cb1/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-3-of-3-c1d912075cb1/</guid>
      <description>Investigating an InvalidProgramException from a memory dump (part 3 of 3) In this series of article, we&amp;rsquo;re retracing how I debugged an InvalidProgramException, caused by a bug in the Datadog profiler, from a memory dump sent by a customer.&#xA;Part 1: Preliminary exploration&#xA;Part 2: Finding the generated IL&#xA;Part 3: Identifying the error and fixing the bug&#xA;In the previous part, we&amp;rsquo;ve located the bad generated IL, stored in an internal CLR structure.</description>
    </item>
    <item>
      <title>Investigating an InvalidProgramException from a memory dump (part 2 of 3)</title>
      <link>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-2-of-3-daaecd8f3cf4/</link>
      <pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-2-of-3-daaecd8f3cf4/</guid>
      <description>In this series of article, we&amp;rsquo;re retracing how I debugged an InvalidProgramException, caused by a bug in the Datadog profiler, from a memory dump sent by a customer.&#xA;Part 1: Preliminary exploration&#xA;Part 2: Finding the generated IL&#xA;Part 3: Identifying the error and fixing the bug&#xA;Let&amp;rsquo;s start with a quick reminder. The profiler works by rewriting the IL of interesting methods to inject instrumentation code. The InvalidProgramException is thrown by the JIT when trying to compile the IL emitted by the profiler, which must be somehow invalid.</description>
    </item>
    <item>
      <title>Investigating an InvalidProgramException from a memory dump (part 1 of 3)</title>
      <link>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-1-of-3-bce634460cc3/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/investigating-an-invalidprogramexception-from-a-memory-dump-part-1-of-3-bce634460cc3/</guid>
      <description>Datadog automated instrumentation for .NET works by rewriting the IL of interesting methods to emit traces that are then sent to the back-end. This is a complex piece of logic, written using the profiler API, and ridden with corner-cases. And as always with complex code, bugs are bound to happen, and those can be very difficult to diagnose.&#xA;As it turns out, we had customer reports of applications throwing InvalidProgramException when using our instrumentation.</description>
    </item>
    <item>
      <title>Tricked by WebRequest</title>
      <link>https://minidump.net/c-tricked-by-webrequest-209014d99653/</link>
      <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/c-tricked-by-webrequest-209014d99653/</guid>
      <description>The Datadog .NET tracer uses the HTTP protocol to communicate with the agent (usually installed on the same machine) and send traces every second. We originally used HttpClient to handle the communication. However, we ran into some dependencies errors on .NET Framework (it&amp;rsquo;s a bit complicated and outside of the scope of the article, but it has something to do with us instrumenting the System.Net.HttpClient assembly while at the same time having a dependency on it), and so we decided to switch to HttpWebRequest.</description>
    </item>
    <item>
      <title>Monitor GC stats with a startup hook</title>
      <link>https://minidump.net/monitor-gc-stats-with-a-startup-hook-55aa03dedea3/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/monitor-gc-stats-with-a-startup-hook-55aa03dedea3/</guid>
      <description>.NET core startup hooks is a feature I really like, and I had a lot of fun with it in the past. Still, I had yet to find a legitimate use for them, and the opportunity finally came a few days ago.&#xA;What are startup hooks? Let&amp;rsquo;s start by a quick catch-up, for those who don&amp;rsquo;t know what startup hooks are. The feature was introduced with .net core 2.2, and allows to execute any arbitrary code in a .</description>
    </item>
    <item>
      <title>Performance best practices in C#</title>
      <link>https://minidump.net/performance-best-practices-in-c-b85a47bdd93a/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/performance-best-practices-in-c-b85a47bdd93a/</guid>
      <description>As I recently had to compile a list of best practices in C# for Criteo, I figured it would be nice to share it publicly. The goal of this article is to provide a non-exhaustive list of code patterns to avoid, either because they&amp;rsquo;re risky or because they perform poorly. The list may seem a bit random because it&amp;rsquo;s out of context, but all the items have been spotted in our code at some point and have caused production issues.</description>
    </item>
    <item>
      <title>.NET ThreadPool starvation, and how queuing makes it worse</title>
      <link>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</guid>
      <description>There has been plenty of talk about ThreadPool starvation in .NET:&#xA;https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/&#xA;https://blogs.msdn.microsoft.com/vsoservice/?p=17665&#xA;Or even on the Criteo&amp;rsquo;s blog: http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/&#xA;What is it about? This is one of the numerous ways asynchronous code can break if you wait synchronously on a task.&#xA;To illustrate that, consider a web server that would execute this code:&#xA;/// ProcessRequest is called for every new request public void ProcessRequest() { DoSomethingAsync().Wait(); } You start an asynchronous operation (DoSomethingAsync) then block the current thread.</description>
    </item>
    <item>
      <title>Dumping stack objects with ClrMD</title>
      <link>https://minidump.net/dumping-stack-objects-with-clrmd-c002dab4651b/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/dumping-stack-objects-with-clrmd-c002dab4651b/</guid>
      <description>The SOS extension for WinDbg defines a command, !DumpStackObjects (or !dso), that allows to list all the references on the stack for a given thread. It&amp;rsquo;s convenient to retrieve the value of arguments or local variables of methods in the callstack. Recently, for an investigation, I ran across the need to dump those values for a few thousand threads. Obviously this is not something you&amp;rsquo;d want to do by hand, so I checked what was possible to do with ClrMD.</description>
    </item>
    <item>
      <title>Debugging and fixing the Twitch desktop client</title>
      <link>https://minidump.net/debugging-and-fixing-the-twitch-desktop-client-d1b38a349186/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/debugging-and-fixing-the-twitch-desktop-client-d1b38a349186/</guid>
      <description>I&amp;rsquo;ve seen through the years that debugging is often misunderstood. Many people that are unfamiliar with debugging tend to think it&amp;rsquo;s all about mastering difficult and austere tools. I often had coworkers ask me &amp;ldquo;what sequence of commands should I type in WinDbg to debug this kind of issue?&amp;rdquo;, as if debugging was about applying a simple flowchart with a complex tool. This is in fact quite the opposite. Debugging is all about the mindset and the methodology, and the tooling is the simple part.</description>
    </item>
    <item>
      <title>Writing ClrMD extensions for WinDbg and LLDB</title>
      <link>https://minidump.net/writing-clrmd-extensions-for-windbg-and-lldb-916427956f66/</link>
      <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/writing-clrmd-extensions-for-windbg-and-lldb-916427956f66/</guid>
      <description>You may have already read the CriteoLabs article about how to write ClrMD extensions for WinDbg. As we move to Linux, we realized that we could not use our debugging toolbox anymore as it was written for WinDbg. Since LLDB is the common debugger for .net NET Core on Linux, I decided to write a compatibility layer to be able to load our extensions in the new environment. And while I was at it, I tried to make the overall process of writing such a debugger extension a bit simpler.</description>
    </item>
    <item>
      <title>Have some fun with .net core startup hooks</title>
      <link>https://minidump.net/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1/</guid>
      <description>One feature of .net core 2.2 that didn&amp;rsquo;t catch my attention immediately is the startup hooks. Put simply, this is a way to register globally a method in an assembly that will be executed whenever a .net core application is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment.&#xA;How does it work? First, you need to create a new .</description>
    </item>
    <item>
      <title>Implementing Java ReferenceQueue and PhantomReference in C#</title>
      <link>https://minidump.net/implementing-java-referencequeue-and-phantomreference-in-c-827d7141b6e4/</link>
      <pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/implementing-java-referencequeue-and-phantomreference-in-c-827d7141b6e4/</guid>
      <description>After reading Konrad Kokosa&amp;rsquo;s article on Java PhantomReference, I got reminded of a coding challenge a coworker gave me a few months ago, about implementing a ReferenceQueue in C#. The Java ReferenceQueue is a mechanism that allows the developer to know when an object has been garbage collected. One of the usages described by Konrad is the ability to cleanup native resources without keeping an object (and its graph of references) in memory.</description>
    </item>
    <item>
      <title>Optimizing the WinDbg DML parser</title>
      <link>https://minidump.net/optimizing-the-windbg-dml-parser-9f64419f9/</link>
      <pubDate>Thu, 03 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/optimizing-the-windbg-dml-parser-9f64419f9/</guid>
      <description>One of my pet project is writing a custom command window for WinDbg. When testing that custom command window with big outputs, I quickly noticed that the performance was unacceptable: the first few lines would be displayed smoothly, then the application would become slower and slower until almost freezing. I therefore decided to optimize my implementation: tweaking the rendering code, batching updates, … But no matter what I did, the performance was still bad.</description>
    </item>
    <item>
      <title>Memory alignment of doubles in C#</title>
      <link>https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/</link>
      <pubDate>Sat, 03 Jan 2009 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/</guid>
      <description>A while ago, I mentioned on Twitter an interesting quirk of objects in .NET: when running in 64 bits, objects are aligned on a 8-bytes boundary despite having a 32 bits header, and therefore 32 bits are &amp;ldquo;lost&amp;rdquo; before each object:&#xA;It bothers me so much that on #dotnet on 64-bit, 4 bytes are wasted for *every class instance* because objects are aligned on a 8 bytes boundary and the header has a fixed size of 4 bytes.</description>
    </item>
  </channel>
</rss>
