<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>async on minidump.net</title>
    <link>https://minidump.net/tags/async/</link>
    <description>Recent content in async on minidump.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Sep 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://minidump.net/tags/async/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Using GC.KeepAlive in async methods</title>
      <link>https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/</link>
      <pubDate>Mon, 05 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/</guid>
      <description>[C#] Using GC.KeepAlive in async methods Can you figure out what&amp;rsquo;s wrong with this code?&#xA;var taskCompletionSource = new TaskCompletionSource(); MyDelegateType myDelegate = () =&amp;gt; taskCompletionSource.SetResult(); NativeMethods.MyNativeMethod(myDelegate); await taskCompletionSource.Task; GC.KeepAlive(myDelegate); It turns out that when running in an actual application, there is a probability that myDelegate will get collected despite the call to GC.KeepAlive.&#xA;This code was posted in an issue in the dotnet/runtime repository, and I followed it closely because I really couldn&amp;rsquo;t tell what the error was.</description>
    </item>
    <item>
      <title>Reading AsyncLocal values from a memory dump</title>
      <link>https://minidump.net/reading-asynclocal-values-from-a-memory-dump-8be356a46b29/</link>
      <pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/reading-asynclocal-values-from-a-memory-dump-8be356a46b29/</guid>
      <description>This article explains how AsyncLocal values are stored in .NET and how to retrieve them from a memory dump. Note that the code provided is written for .NET 5, but should be able to work for .NET Framework with minor modifications (the name of some internal fields have changed across versions).&#xA;Preparing the memory dump First thing first, we need to prepare the memory dump that will serve as example for the whole article.</description>
    </item>
    <item>
      <title>.NET ThreadPool starvation, and how queuing makes it worse</title>
      <link>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</link>
      <pubDate>Mon, 27 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527/</guid>
      <description>There has been plenty of talk about ThreadPool starvation in .NET:&#xA;https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/&#xA;https://blogs.msdn.microsoft.com/vsoservice/?p=17665&#xA;Or even on the Criteo&amp;rsquo;s blog: http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/&#xA;What is it about? This is one of the numerous ways asynchronous code can break if you wait synchronously on a task.&#xA;To illustrate that, consider a web server that would execute this code:&#xA;/// ProcessRequest is called for every new request public void ProcessRequest() { DoSomethingAsync().Wait(); } You start an asynchronous operation (DoSomethingAsync) then block the current thread.</description>
    </item>
    <item>
      <title>Switching back to the UI thread in WPF/UWP, in modern C#</title>
      <link>https://minidump.net/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://minidump.net/switching-back-to-the-ui-thread-in-wpf-uwp-in-modern-c-5dc1cc8efa5e/</guid>
      <description>It may seem weird that in 2020 I would write an article on this subject. But I found a new approach to this problem that I had some fun experimenting with.&#xA;So what is the problem, to begin with?&#xA;A quick reminder In WinForms/WPF/UWP, you can only update controls from the UI thread. If you have code running in a background thread that needs to update some controls, you need to somehow switch to the UI thread.</description>
    </item>
  </channel>
</rss>
