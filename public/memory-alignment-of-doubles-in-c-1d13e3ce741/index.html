<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Memory alignment of doubles in C#",
  
  "image": "https://minidump.net/images/memory-alignment-of-doubles-in-c-1d13e3ce741-1.webp",
  
  "datePublished": "2023-09-30T00:00:00Z",
  "dateModified": "2023-09-30T00:00:00Z",
  "author": {
    "@type": "Person",
    "name": "Kevin Gosse",
    
    "image": "https://minidump.net/images/profile.png"
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/minidump.net\/memory-alignment-of-doubles-in-c-1d13e3ce741\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "minidump.net",
    
    "logo": {
      "@type": "ImageObject",
      "url": "https://minidump.net/images/profile.png"
    }
    
  },
  "description": "A deep dive into the weird tricks used by the .NET allocator to align arrays of doubles.",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.121.1 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="Kevin Gosse">
<meta name="keywords" content="">
<meta name="description" content="A deep dive into the weird tricks used by the .NET allocator to align arrays of doubles.">


<meta property="og:description" content="A deep dive into the weird tricks used by the .NET allocator to align arrays of doubles.">
<meta property="og:type" content="article">
<meta property="og:title" content="Memory alignment of doubles in C#">
<meta name="twitter:title" content="Memory alignment of doubles in C#">
<meta property="og:url" content="https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/">
<meta property="twitter:url" content="https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/">
<meta property="og:site_name" content="minidump.net">
<meta property="og:description" content="A deep dive into the weird tricks used by the .NET allocator to align arrays of doubles.">
<meta name="twitter:description" content="A deep dive into the weird tricks used by the .NET allocator to align arrays of doubles.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2023-09-30T00:00:00">
  
  
    <meta property="article:modified_time" content="2023-09-30T00:00:00">
  
  
  
  
    
      <meta property="article:tag" content="dotnet">
    
      <meta property="article:tag" content="cpp">
    
      <meta property="article:tag" content="garbage-collection">
    
      <meta property="article:tag" content="performance">
    
  


<meta name="twitter:card" content="summary">

  <meta name="twitter:site" content="@kookiz">


  <meta name="twitter:creator" content="@kookiz">






  <meta property="og:image" content="https://minidump.net/images/profile.png">
  <meta property="twitter:image" content="https://minidump.net/images/profile.png">





  <meta property="og:image" content="https://minidump.net/images/memory-alignment-of-doubles-in-c-1d13e3ce741-1.webp">
  <meta property="twitter:image" content="https://minidump.net/images/memory-alignment-of-doubles-in-c-1d13e3ce741-1.webp">


    <title>Memory alignment of doubles in C#</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://minidump.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/" aria-label="Go to homepage">minidump.net</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Kevin Gosse</h4>
        
          <h5 class="sidebar-profile-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/kookiz" target="_blank" rel="noopener" title="Twitter">
    
      <i class="sidebar-button-icon fab fa-lg fa-twitter" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/kevingosse" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.buymeacoffee.com/kevingosse" target="_blank" rel="noopener" title="Buy me a coffee">
    
      <i class="sidebar-button-icon fas fa-lg fa-coffee" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Buy me a coffee</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaIn
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title">
      Memory alignment of doubles in C#
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2023-09-30T00:00:00Z">
        
  
  
  
  
    September 30 2023
  

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <p>A while ago, I mentioned on Twitter an interesting quirk of objects in .NET: when running in 64 bits, objects are aligned on a 8-bytes boundary despite having a 32 bits header, and therefore 32 bits are &ldquo;lost&rdquo; before each object:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">It bothers me so much that on <a href="https://twitter.com/hashtag/dotnet?src=hash&amp;ref_src=twsrc%5Etfw">#dotnet</a> on 64-bit, 4 bytes are wasted for *every class instance* because objects are aligned on a 8 bytes boundary and the header has a fixed size of 4 bytes. <a href="https://t.co/kToB6rnABG">pic.twitter.com/kToB6rnABG</a></p>&mdash; Kevin Gosse (@KooKiz) <a href="https://twitter.com/KooKiz/status/1692931201550446891?ref_src=twsrc%5Etfw">August 19, 2023</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>And then, Egor Bogatov replied with a funny bit of trivia about how arrays of doubles are aligned using a fake object:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The funny case is how it&#39;s implemnted for a normal heaps (not LOH) on x86: if we have, say, double[100] and current GC&#39;s allocator is only 4-bytes aligned - we allocate a fake object of variable size to make next object 8-bytes aligned :)</p>&mdash; Egor Bogatov (@EgorBo) <a href="https://twitter.com/EgorBo/status/1693006499428110344?ref_src=twsrc%5Etfw">August 19, 2023</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>It really got my attention and I spent the next few days digging into how arrays of doubles are aligned in .NET, and today I&rsquo;m taking you down with me.</p>
<h1 id="the-cost-of-unaligned-doubles">The cost of unaligned doubles</h1>
<p>The first question to answer is: why should we align doubles at all? And the answer is… well, I&rsquo;m not sure. Please take the next few paragraphs with a pinch of salt: I&rsquo;m no expert in that domain, and it&rsquo;s only information I&rsquo;ve gathered from various articles or online discussions.</p>
<p>From what I&rsquo;ve read, it&rsquo;s a combination of two factors:</p>
<ul>
<li>
<p>On older x86–64 CPUs, accessing unaligned data had a significant performance penalty. Apparently that&rsquo;s hardly the case anymore, Intel and AMD did a fine job bringing that cost down to zero or close to zero. Maybe that&rsquo;s still the case on other architectures, I don&rsquo;t know.</p>
</li>
<li>
<p>If doubles are not aligned on 8-byte boundaries, there is a risk that they may span two cache lines, leading to less efficient memory access.</p>
</li>
</ul>
<p>Overall, the consensus seems to be that it used to be bad, but today not so much.</p>
<p>I decided to see by myself, and wrote a benchmark to try and measure the cost of unaligned memory access with doubles.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DoublesBenchmark</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">void</span>* Memory;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Count = <span style="color:#ae81ff">10_000</span>;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [Params(0, 4, 8, 12, 16)]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> Offset { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> DoublesBenchmark()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Memory = NativeMemory.AlignedAlloc(Count * <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) + <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [Benchmark]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">double</span> Sum()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> doubles = <span style="color:#66d9ef">new</span> Span&lt;<span style="color:#66d9ef">double</span>&gt;((<span style="color:#66d9ef">byte</span>*)Memory + Offset, Count);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> result = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span> (<span style="color:#66d9ef">var</span> <span style="color:#66d9ef">value</span> <span style="color:#66d9ef">in</span> doubles)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            result += <span style="color:#66d9ef">value</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The idea is to allocate a chunk of native memory (aligned on an 8 bytes boundary), then interpret it as a sequence of doubles starting at a variable offset.</p>
<pre tabindex="0"><code>// * Summary *

BenchmarkDotNet v0.13.7, Windows 10 (10.0.19045.3448/22H2/2022Update)
Intel Core i7-5820K CPU 3.30GHz (Broadwell), 1 CPU, 12 logical and 6 physical cores
.NET SDK 8.0.100-rc.1.23463.5
  [Host] : .NET 8.0.0 (8.0.23.41904), X86 RyuJIT AVX2

Job=InProcess  Toolchain=InProcessEmitToolchain

| Method | Offset |     Mean |     Error |    StdDev |
|------- |------- |---------:|----------:|----------:|
|    Sum |      0 | 8.774 us | 0.0324 us | 0.0288 us |
|    Sum |      4 | 8.981 us | 0.0449 us | 0.0398 us |
|    Sum |      8 | 8.789 us | 0.0457 us | 0.0427 us |
|    Sum |     12 | 8.969 us | 0.0597 us | 0.0559 us |
|    Sum |     16 | 8.780 us | 0.0371 us | 0.0347 us |
</code></pre><p>We can see that the mean execution time is higher by about 2% when the doubles are aligned on a 4-bytes boundary (offsets 4 and 12), compared to the 8-bytes boundary (offsets 0, 8, and 16). This is hardly the end of the world, but that&rsquo;s still significant. I&rsquo;ve tried many variations of the benchmark (including with random access instead of sequential) and always find a difference of about 2%.</p>
<h1 id="alignment-of-arrays-of-doubles-in-net">Alignment of arrays of doubles in .NET</h1>
<p>Now that we have empirical evidence of the benefits of aligning doubles, let&rsquo;s see what the .NET runtime does about that. When running in 64-bit, all objects are aligned on a 8-bytes boundary, so there&rsquo;s nothing special to do about doubles. But what if the application is running in 32-bit?</p>
<p>There is a special mechanism to lower the LOH threshold for arrays of double. The LOH is aligned on 8 bytes even when running in 32-bit, so allocating the arrays of double there is a way of ensuring that they&rsquo;re properly aligned. See the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Console.WriteLine(GC.GetGeneration(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">999</span>])); <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(GC.GetGeneration(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">1000</span>])); <span style="color:#75715e">// 2</span>
</span></span></code></pre></div><p>If an array of double has at least 1000 elements, it gets allocated in the LOH, despite being much smaller than the 85,000 bytes threshold. That number can be tweaked using the<code>DOTNET_DoubleArrayToLargeObjectHeap</code> environment variable.</p>
<p>For instance, if I set <code>DOTNET_DoubleArrayToLargeObjectHeap</code> to 0, then all arrays of doubles are allocated in the LOH, regardless of size:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Console.WriteLine(GC.GetGeneration(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">0</span>])); <span style="color:#75715e">// 2</span>
</span></span><span style="display:flex;"><span>Console.WriteLine(GC.GetGeneration(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">1</span>])); <span style="color:#75715e">// 2</span>
</span></span></code></pre></div><p>Great. But what about arrays that have fewer elements than the <code>DoubleArrayToLargeObjectHeap</code> threshold? A quick test shows that they are still aligned on 8 bytes, despite not being allocated in the LOH:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsAligned(<span style="color:#66d9ef">object</span> obj)  =&gt; ((nint)(&amp;obj) &amp; <span style="color:#ae81ff">0x7</span>) == <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; <span style="color:#ae81ff">10</span>; i++)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> array = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    Console.WriteLine(GC.GetGeneration(array)); <span style="color:#75715e">// 0</span>
</span></span><span style="display:flex;"><span>    Console.WriteLine(IsAligned(array)); <span style="color:#75715e">// true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This article could stop here, but as hinted at the beginning, there is an interesting hack involved under the hood to force that alignment.</p>
<h1 id="filling-in-the-blanks">Filling in the blanks</h1>
<p>To understand what happens, you must first learn about the allocation context. Nowadays, applications are massively multithreaded, and if each thread needed to talk to the GC every time they allocate an object, it would cause a lot of contention. Instead, every thread is given a personal allowance, a segment of zero&rsquo;d memory that they can use as needed. Every time the code tries to allocate a new reference object, the thread tries to use the memory from its allocation context. When there is no room left, the thread asks ̶m̶o̶m̶m̶y̶ the GC for a new allocation context. When the GC is out of memory to give (or when it judges that it has given too much memory already), a garbage collection is triggered.</p>
<p>In practice, the allocation context is a structure that contains, among other things, a pointer to the beginning of its allotted memory (in the <code>alloc_ptr</code> field) and a pointer to the end of that memory (in the <code>alloc_limit</code> field).</p>
<p>Two completely different code paths are used depending on whether there&rsquo;s room left in the allocation context (fast path) or the thread has to ask for more (slow path). We&rsquo;re going to see what happens in both.</p>
<h1 id="the-fast-path">The fast path</h1>
<p>The fast path is in fact multiple paths. Specialized allocation methods are emitted for specific cases, and written in assembly code. And there are many of them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    CORINFO_HELP_NEWFAST,
</span></span><span style="display:flex;"><span>    CORINFO_HELP_NEWFAST_MAYBEFROZEN, <span style="color:#75715e">// allocator for objects that *might* allocate them on a frozen segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWSFAST,          <span style="color:#75715e">// allocator for small, non-finalizer, non-array object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWSFAST_FINALIZE, <span style="color:#75715e">// allocator for small, finalizable, non-array object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWSFAST_ALIGN8,   <span style="color:#75715e">// allocator for small, non-finalizer, non-array object, 8 byte aligned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWSFAST_ALIGN8_VC,<span style="color:#75715e">// allocator for small, value class, 8 byte aligned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWSFAST_ALIGN8_FINALIZE, <span style="color:#75715e">// allocator for small, finalizable, non-array object, 8 byte aligned
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEW_MDARR,<span style="color:#75715e">// multi-dim array helper for arrays Rank != 1 (with or without lower bounds - dimensions passed in as unmanaged array)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEW_MDARR_RARE,<span style="color:#75715e">// rare multi-dim array helper (Rank == 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWARR_1_DIRECT,   <span style="color:#75715e">// helper for any one dimensional array creation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWARR_1_MAYBEFROZEN, <span style="color:#75715e">// allocator for arrays that *might* allocate them on a frozen segment
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWARR_1_OBJ,      <span style="color:#75715e">// optimized 1-D object arrays
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWARR_1_VC,       <span style="color:#75715e">// optimized 1-D value class arrays
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    CORINFO_HELP_NEWARR_1_ALIGN8,   <span style="color:#75715e">// like VC, but aligns the array start
</span></span></span></code></pre></div><p>The one we&rsquo;re going to focus on is <code>CORINFO_HELP_NEWARR_1_ALIGN8</code>, used for 1-dimensional arrays that need to be aligned on an 8 byte boundary. In other words, the one used when allocating an instance of <code>double[]</code>.</p>
<p>On x86, those helpers are emitted <a href="https://github.com/dotnet/runtime/blob/c4f8c3b27a8fb2e452a57a6516050c8c2ee677f4/src/coreclr/vm/i386/jitinterfacex86.cpp#L222">by a C++ method</a> that generates assembly code depending on a set of conditions.</p>
<p>Before digging in, let&rsquo;s take a minute to think about what that allocation code <em>should</em> look like. Remember, we&rsquo;re focusing on the case of a 32-bit process.</p>
<p>Every heap allocation has a size that is a multiple of the pointer size. Even if you&rsquo;re feeling playful and box a struct of 13 bytes, it will be padded to 16 bytes (and will occupy a total of 24 bytes in memory because of the header and the method-table pointer). Because of this, we know that the allocation pointer (the pointer in the allocation context that indicates where the available zero&rsquo;d memory starts) is always aligned on 4 bytes.</p>
<p>Then one of two thing should happen:</p>
<ul>
<li>
<p>Either we&rsquo;re lucky and the allocation pointer is also aligned on 8 bytes (since 8 is the smallest multiple of 4, it should happen fairly often), then we can directly allocate the array. Allocating the array means bumping the value of the allocation pointer by the size of the array, then returning the old value.</p>
</li>
<li>
<p>Or the allocation pointer is not properly aligned, in which case we should bump it by 4 bytes before allocating the array.</p>
</li>
</ul>
<p>In practice, this is not what happens:</p>
<ul>
<li>
<p>In the lucky case, when the allocation pointer is aligned on 8 bytes, then no surprise: the array is directly allocated as expected.</p>
</li>
<li>
<p>In the unlucky case, the allocation pointer is bumped by 12 bytes (instead of just 4). Those 12 bytes are used to allocate an instance of <code>Object</code>. Following that allocation, the allocation pointer is correctly aligned (4 + 12 = 16, which is a multiple of 8) so the array can be allocated.</p>
</li>
</ul>
<p>You may be wondering why 12 bytes for an <code>Object</code>. In .NET, because of some requirements dictated by the GC, heap allocations can&rsquo;t be smaller than 3 pointers. So even a simple <code>Object</code> will use 12 bytes on 32-bit, and 24 bytes on 64-bit.</p>
<p>But then comes the real puzzle: why allocating an actual object instead of just bumping the allocation pointer by 4? It&rsquo;s 8 extra bytes that are apparently wasted? I don&rsquo;t know what the official reason is, but I see at least one scenario that would be problematic if we just left an empty gap in memory: scanning the heap.</p>
<h1 id="how-to-scan-the-heap">How to scan the heap</h1>
<p>Scanning the heap is usually done by the GC, but can also be done by debugging tools (for instance, the <code>!dumpheap</code> command in Windbg/dotnet-dump). Objects are not indexed, there is no central repository you can read to know where each object is located. Instead, you need to read the raw memory and figure out what is an object and what is not.</p>
<p>First you need to know where the managed heaps start and end. Fortunately there are structures in memory for that. Then you assume that the heap starts with an allocated object, and read it&rsquo;s method table. The method table contains a &ldquo;base size&rdquo; field, that tells you how big the object is in memory. From there, you can simply jump that amount of bytes in memory to find the next object and read its method table, and so on (of course it&rsquo;s simplified, for instance arrays have a variable size).</p>
<p>This is all nice, but it assumes that objects are neatly packed in memory. What about the &ldquo;holes&rdquo; left by the GC when memory is fragmented? They&rsquo;re actually filled with instances of a special object, <code>Free</code>, which has a variable size just like an array. You can actually see them when running the <code>!dumpheap</code> command in Windbg:</p>
<pre tabindex="0"><code>0:000&gt; !dumpheap
 Address       MT           Size
05831000 03109810             12 Free
0583100c 03109810             12 Free
05831018 03109810             12 Free
05831024 211e92e0             12 
05831030 211e9648             20 
05831044 05565ee0             12 
05831050 211ac80c             32 
06831000 03109810             12 Free
0683100c 03109810             12 Free
06831018 03109810             12 Free
07831000 03109810             12 Free
0783100c 03109810             12 Free
07831018 1f393bf0             44 
07831044 1f3903fc             24 
0783105c 1f393c94             24 
07831074 1f36a8d0             56 
</code></pre><p>The pseudo-code to scan the heap would look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-php" data-lang="php"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">scan_heap</span>(<span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">current</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">start</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">current</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">end</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mt</span> <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">current</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">mt</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">free_mt</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Found free object&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Found object of type &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">GetObjectName</span>(<span style="color:#a6e22e">mt</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Simplified. For arrays, we would also need to consider their length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">current</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">mt</span><span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">base_size</span>; 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this knowledge, it becomes apparent why we can&rsquo;t just bump the allocation pointer by 4 bytes. We would end up with 4 bytes of garbage and we wouldn&rsquo;t know where to read next (though, if the empty memory is zero&rsquo;d, I suppose we could just read everything until we find something that is not zero). Instead, we need to fill the gap with an object, so we can use its base size to find where the next &ldquo;real&rdquo; object starts.</p>
<p>There&rsquo;s still one peculiar unexplained point: why does the fast path allocate an actual <code>Object</code> instead of the special <code>Free</code> object? And the answer is… I don&rsquo;t know. I&rsquo;ve thought long and hard about it, and couldn&rsquo;t come up with a satisfying reason. Especially because, when moving the objects in memory, the GC does use instances of <code>Free</code> to align them. Why isn&rsquo;t the allocator doing the same? I have no clue.</p>
<h1 id="locating-the-dummy-object">Locating the dummy object</h1>
<p>Wouldn&rsquo;t it be &ldquo;fun&rdquo; if we could actually observe that dummy object? First, we can observe it directly from the memory view of the debugger.</p>
<p>To do so, we need a way to make sure the allocation pointer is not aligned on 8 bytes. The allocation pointer is stored on the native <code>Thread</code> object, and we can retrieve it by using some deliciously unsafe C# code.</p>
<p>We start by declaring a helper method to retrieve a pointer to the native thread, using the private <code>_DONT_USE_InternalThread</code> field (rather than reflection, we use the brand new .NET 8 <a href="https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafeaccessorattribute?view=net-8.0&amp;WT.mc_id=DT-MVP-5003493"><code>UnsafeAccessor</code></a> to access it). We interpret its contents using <code>Thread_data</code> and <code>gc_alloc_context</code> structs that mimic the layout of their native counterparts.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">ref</span> Thread_data GetCurrentNativeThread()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> currentNativeThread = GetNativeThread(Thread.CurrentThread);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">ref</span> Unsafe.AsRef&lt;Thread_data&gt;((<span style="color:#66d9ef">void</span>*)currentNativeThread);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[UnsafeAccessor(UnsafeAccessorKind.Field, Name = &#34;_DONT_USE_InternalThread&#34;)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">ref</span> IntPtr GetNativeThread(Thread thread);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[StructLayout(LayoutKind.Sequential)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Thread_data</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint vtable;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> m_state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> m_fPreemptiveGCDisabled;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_pFrame;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_pDomain;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> m_ThreadId;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_pHead;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> LockEntry m_embeddedEntry;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_pBlockingLock;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> gc_alloc_context m_alloc_context;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_thAllocContextObj;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint m_pTEB;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[StructLayout(LayoutKind.Sequential)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">gc_alloc_context</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint alloc_ptr;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint alloc_limit;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> alloc_bytes;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> alloc_bytes_uoh;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint gc_reserved_1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> nint gc_reserved_2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> alloc_count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With those helper methods, we retrieve the allocation context and check whether the next allocation is going to be aligned on 8 bytes. If yes, then we box an <code>int</code> to offset the allocation pointer by 12 bytes (remember, 12 bytes is the minimum size of objects on the heap). Then we allocate our array of doubles. We print the address of the array, along with the method-table pointer of <code>double[]</code> and <code>Object</code> to help interpret the raw memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsAligned(nint address)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (address &amp; <span style="color:#ae81ff">0x7</span>) == <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> nint GetAddress(<span style="color:#66d9ef">object</span> obj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (nint)(*(<span style="color:#66d9ef">object</span>**)&amp;obj);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">$&#34;Object MT: {typeof(object).TypeHandle.Value:x2}&#34;</span>);
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">$&#34;Double[] MT: {typeof(double[]).TypeHandle.Value:x2}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">var</span> allocContext = <span style="color:#66d9ef">ref</span> GetCurrentNativeThread().m_alloc_context;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">object</span> padding = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsAligned(allocContext.alloc_ptr))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        padding = (<span style="color:#66d9ef">object</span>)<span style="color:#ae81ff">0xFFFFFFFF</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> array = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">$&#34;Array address: {GetAddress(array):x2}&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// Add a breakpoint here</span>
</span></span><span style="display:flex;"><span>   Console.ReadLine();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   GC.KeepAlive(padding);
</span></span><span style="display:flex;"><span>   GC.KeepAlive(array);
</span></span></code></pre></div><p>We can see the result of the execution in the console:</p>
<pre tabindex="0"><code>Object MT: 5035ee0
Double[] MT: 2119ce70
Array address: 759c0a0
</code></pre><p>And the raw memory:</p>


 
  
  
  
  
    
  
    
      
    
  

<div class="figure center" >
  
    <a class="fancybox" href="/images/memory-alignment-of-doubles-in-c-1d13e3ce741-1.webp" data-fancybox="">
  
    <img class="fig-img" src="/images/memory-alignment-of-doubles-in-c-1d13e3ce741-1.webp" >
  
    </a>
  
  
</div>

<p>In blue, we can see the boxed <code>int</code> used for padding (recognizable by the value <code>0xffffffff</code>). In red, we see the array of doubles (an empty header, the method-table pointer <code>2119ce70</code>, the number of elements <code>2</code>, then two empty doubles). And in-between, we see the dummy object inserted by the allocator, in green.</p>
<p>Now that&rsquo;s we&rsquo;ve &ldquo;seen&rdquo; the dummy object, let&rsquo;s push things one step further: can we actually retrieve a reference to it?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> objectMT = <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">object</span>).TypeHandle.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">var</span> allocContext = <span style="color:#66d9ef">ref</span> GetCurrentNativeThread().m_alloc_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">object</span> padding = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsAligned(allocContext.alloc_ptr))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        padding = (<span style="color:#66d9ef">object</span>)<span style="color:#ae81ff">0xFFFFFFFF</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> array = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> address = GetAddress(array);
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> dummyObjectAddress = address - <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (*(nint*)dummyObjectAddress == objectMT)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">object</span> dummyObject = *(<span style="color:#66d9ef">object</span>*)&amp;dummyObjectAddress;
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Found: {dummyObject}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;The dummy object wasn&#39;t found :(&#34;</span>);        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And sure enough, the program will display in the console:</p>
<pre tabindex="0"><code>Found: System.Object
</code></pre><h1 id="the-slow-path">The slow path</h1>
<p>There&rsquo;s another peculiarity in the allocator code, this time in the slow path. The slow path is executed whenever there is not enough room left in the allocation context for the current allocation. The thread then has to ask the heap allocator for the needed amount of memory. The heap allocator returns a pointer to a chunk of memory of the desired size, and grants a new allocation context to the thread as a side-effect.</p>
<p>But the heap allocator has no API to return memory aligned on an 8-byte boundary, so more tricks are used. Instead of asking for the amount of memory needed for the array, the thread asks for that amount + 12 bytes. If the returned address is not aligned, then a dummy object is stored in the first 12 bytes, and the array in the remainder. But if the returned address is already aligned, then the thread stores the array and then… ends up with 12 bytes of unused memory. We&rsquo;ve already seen that we can&rsquo;t leave empty memory, so a dummy object is stored in the leftover.</p>
<p>In the fast path, we ended up with a dummy object whenever the address was not aligned, which sort of made sense… But in the slow path, we end up with a dummy object no matter what! Why not just ask for the size needed for the array, then ask for another extra 12 bytes only if the address is not aligned? Well, simply because when called, the heap allocator might decide to rebalance the heaps or trigger a garbage collection, so there is no guarantee that those 12 bytes will be contiguous with the memory previously returned.</p>
<p>Let&rsquo;s update our program to test this behavior. It&rsquo;s slightly more complex because we need to make sure that our array of double exceeds the size left in the allocation context. To compute the size left, we substract the pointer to the end of the allocation context (<code>alloc_limit</code>) from the pointer to the beginning of the allocation context (<code>alloc_ptr</code>). There&rsquo;s one subtlety though: we need to make sure that there isn&rsquo;t too much space available in the allocation context to begin with. If there are more than 8000 bytes available, then we will need to allocate an array of more than 1000 elements. And as we&rsquo;ve seen previously, those get allocated directly in the LOH, so the allocation context won&rsquo;t be used. To prevent that, we first allocate an array of bytes big enough to leave only ~500 bytes in the allocation context.</p>
<p>With that in mind, let&rsquo;s write a <code>FindDummyObject</code> method, that tries to locate the dummy object after allocating an array of double. The method takes one parameter, indicating whether the allocation context pointer should be initially aligned or not.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">void</span> FindDummyObject(<span style="color:#66d9ef">bool</span> alignArray)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> objectMT = <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">object</span>).TypeHandle.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Minimize the probability of having a collection during the scenario</span>
</span></span><span style="display:flex;"><span>    GC.Collect();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> bag = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">object</span>&gt;(<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">var</span> allocContext = <span style="color:#66d9ef">ref</span> GetCurrentNativeThread().m_alloc_context;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> budget = allocContext.alloc_limit - allocContext.alloc_ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (budget &gt; <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) * <span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If there&#39;s too much budget left, we&#39;ll end up allocating an array of more than 1000 elements</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// which will be allocated in the large object heap, and we won&#39;t be able to find the dummy object</span>
</span></span><span style="display:flex;"><span>        bag.Add(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span>[budget - <span style="color:#ae81ff">500</span>]);
</span></span><span style="display:flex;"><span>        budget = allocContext.alloc_limit - allocContext.alloc_ptr;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsAligned(allocContext.alloc_ptr) != alignArray)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Allocate 12 bytes to change the alignment</span>
</span></span><span style="display:flex;"><span>        bag.Add((<span style="color:#66d9ef">object</span>)<span style="color:#ae81ff">0xFFFFFFFF</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> length = budget / <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) + <span style="color:#ae81ff">10</span> <span style="color:#75715e">/* add a few elements just to be sure */</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> array = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[length];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Now try to find the dummy object</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> address = GetAddress(array);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Compute the address that the dummy object would have</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if it&#39;s stored after the array</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> dummyObjectAddress = address
</span></span><span style="display:flex;"><span>        + <span style="color:#ae81ff">4</span> <span style="color:#75715e">/* MT pointer of the array */</span>
</span></span><span style="display:flex;"><span>        + <span style="color:#ae81ff">4</span> <span style="color:#75715e">/* length of the array */</span>
</span></span><span style="display:flex;"><span>        + <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">double</span>) * array.Length <span style="color:#75715e">/* content of the array */</span>
</span></span><span style="display:flex;"><span>        + <span style="color:#ae81ff">4</span> <span style="color:#75715e">/* Header of dummy object */</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (*(nint*)dummyObjectAddress == objectMT)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">object</span> dummyObject = *(<span style="color:#66d9ef">object</span>*)&amp;dummyObjectAddress;
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">$&#34;Found dummy object AFTER the array: {dummyObject}&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The dummy object wasn&#39;t found after the array, check before</span>
</span></span><span style="display:flex;"><span>        dummyObjectAddress = address - <span style="color:#ae81ff">12</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (*(nint*)dummyObjectAddress == objectMT)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">object</span> dummyObject = *(<span style="color:#66d9ef">object</span>*)&amp;dummyObjectAddress;
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">$&#34;Found dummy object BEFORE the array: {dummyObject}&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            Console.WriteLine(<span style="color:#e6db74">&#34;The dummy object wasn&#39;t found :(&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    GC.KeepAlive(bag);
</span></span><span style="display:flex;"><span>    GC.KeepAlive(array);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And we call the method with both values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsafe</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">&#34;With aligned address&#34;</span>);
</span></span><span style="display:flex;"><span>    FindDummyObject(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>    Console.WriteLine();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">&#34;With unaligned address&#34;</span>);
</span></span><span style="display:flex;"><span>    FindDummyObject(<span style="color:#66d9ef">false</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After execution, the result is:</p>
<pre tabindex="0"><code>With aligned address
Found dummy object BEFORE the array: System.Object

With unaligned address
Found dummy object AFTER the array: System.Object
</code></pre><p>Great!</p>
<p>Wait… Shouldn&rsquo;t it be the opposite? Shouldn&rsquo;t the dummy object be allocated <em>after</em> the array when the allocation pointer is aligned? It turns out that when assigning a new allocation context, the GC allocates a 12 bytes <code>Free</code> object at the beginning of it. Because of this, the alignment is actually inverted compared to what we expected (= if the allocation context was aligned, it will become unaligned when expanding it because of those 12 bytes added at the beginning).</p>
<h1 id="wrapping-it-up">Wrapping it up</h1>
<p>That… was a lot of hours spent on a single tweet. Even then, there are plenty of approximations in this article, which reflects the complexity of memory management in .NET. If somebody can figure out why the allocator uses an instance of <code>Object</code> instead of <code>Free</code>, I&rsquo;d love to hear about it.</p>

              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/dotnet/">dotnet</a>

  <a class="tag tag--primary tag--small" href="/tags/cpp/">cpp</a>

  <a class="tag tag--primary tag--small" href="/tags/garbage-collection/">garbage-collection</a>

  <a class="tag tag--primary tag--small" href="/tags/performance/">performance</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/suppressgctransition-b9a8a774edbd/" data-tooltip="SuppressGCTransition" aria-label="PREVIOUS: SuppressGCTransition">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            

<link href="https://fonts.googleapis.com/css?family=Cookie&amp;display=swap" rel="stylesheet">
<div class="bmc-btn-container"><a class="bmc-btn" target="_blank" href="https://buymeacoffee.com/kevingosse">☕<span class="bmc-btn-text">Enjoyed the article? Buy me a coffee</span></a></div>

<style>
    .bmc-btn {
        min-width: 210px;
        color: #000000;
        background-color: #FFFFFF !important;
        height: 60px;
        border-radius: 12px;
        font-size: 28px;
        font-weight: Normal;
        border: none;
        line-height: 27px;
        text-decoration: none !important;
        display: inline-flex !important;
        justify-content: center;
        align-items: center;
        font-family: 'Cookie', cursive !important;
        -webkit-box-sizing: border-box !important;
        box-sizing: border-box !important;
    }

    .bmc-btn:hover, .bmc-btn:active, .bmc-btn:focus {
        text-decoration: none !important;
        cursor: pointer;
    }

    .bmc-btn-text {
        margin-left: 8px;
        display: inline-block;
        line-height: 0;
        width: 100%;
        flex-shrink: 0;
        font-family: [FONT] !important;
    }

    .logo-outline {
        fill: #000000;
    }

    .logo-coffee {
        fill: #ffffff;
    }</style>

  
<div id="utterances">
      <noscript>Please enable JavaScript to view the comments powered by Utterances.</noscript>
    </div>
<script src="https://utteranc.es/client.js"
        repo="kevingosse/kevingosse.github.io"
        issue-term="title"
        label="comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2023 Kevin Gosse. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--disabled">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/suppressgctransition-b9a8a774edbd/" data-tooltip="SuppressGCTransition" aria-label="PREVIOUS: SuppressGCTransition">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/memory-alignment-of-doubles-in-c-1d13e3ce741/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      
<div id="share-options-bar" class="share-options-bar" data-behavior="2">
  <i id="btn-close-shareoptions" class="fa fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fminidump.net%2Fmemory-alignment-of-doubles-in-c-1d13e3ce741%2F" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https%3A%2F%2Fminidump.net%2Fmemory-alignment-of-doubles-in-c-1d13e3ce741%2F" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i><span>Share on Linkedin</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.reddit.com/submit?url=https%3A%2F%2Fminidump.net%2Fmemory-alignment-of-doubles-in-c-1d13e3ce741%2F" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i><span>Share on Reddit</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fminidump.net%2Fmemory-alignment-of-doubles-in-c-1d13e3ce741%2F" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i><span>Share on Hacker News</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>


    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Kevin Gosse</h4>
    
      <div id="about-card-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</div>
    
    
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://minidump.net/images/code.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://minidump.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

