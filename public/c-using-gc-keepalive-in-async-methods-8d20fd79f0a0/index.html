<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <script type="application/ld+json">

{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Using GC.KeepAlive in async methods",
  
  "image": "https://minidump.net/images/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0-1.webp",
  
  "datePublished": "2022-09-05T00:00:00Z",
  "dateModified": "2022-09-05T00:00:00Z",
  "author": {
    "@type": "Person",
    "name": "Kevin Gosse",
    
    "image": "https://minidump.net/images/profile.png"
    
  },
  "mainEntityOfPage": { 
    "@type": "WebPage",
    "@id": "https:\/\/minidump.net\/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0\/" 
  },
  "publisher": {
    "@type": "Organization",
    "name": "minidump.net",
    
    "logo": {
      "@type": "ImageObject",
      "url": "https://minidump.net/images/profile.png"
    }
    
  },
  "description": "GC.KeepAlive may not work the way you intend when using it in async methods.",
  "keywords": []
}

</script>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.121.1 with theme Tranquilpeak 0.5.3-BETA">
<meta name="author" content="Kevin Gosse">
<meta name="keywords" content="">
<meta name="description" content="GC.KeepAlive may not work the way you intend when using it in async methods.">


<meta property="og:description" content="GC.KeepAlive may not work the way you intend when using it in async methods.">
<meta property="og:type" content="article">
<meta property="og:title" content="Using GC.KeepAlive in async methods">
<meta name="twitter:title" content="Using GC.KeepAlive in async methods">
<meta property="og:url" content="https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/">
<meta property="twitter:url" content="https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/">
<meta property="og:site_name" content="minidump.net">
<meta property="og:description" content="GC.KeepAlive may not work the way you intend when using it in async methods.">
<meta name="twitter:description" content="GC.KeepAlive may not work the way you intend when using it in async methods.">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2022-09-05T00:00:00">
  
  
    <meta property="article:modified_time" content="2022-09-05T00:00:00">
  
  
  
  
    
      <meta property="article:tag" content="dotnet">
    
      <meta property="article:tag" content="async">
    
  


<meta name="twitter:card" content="summary">

  <meta name="twitter:site" content="@kookiz">


  <meta name="twitter:creator" content="@kookiz">






  <meta property="og:image" content="https://minidump.net/images/profile.png">
  <meta property="twitter:image" content="https://minidump.net/images/profile.png">





  <meta property="og:image" content="https://minidump.net/images/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0-1.webp">
  <meta property="twitter:image" content="https://minidump.net/images/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0-1.webp">


    <title>Using GC.KeepAlive in async methods</title>

    <link rel="icon" href="/favicon.png">
    

    

    <link rel="canonical" href="https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    
    
    <link rel="stylesheet" href="https://minidump.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css" />
    
    

    
      
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MQCXFBVCCM"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-MQCXFBVCCM', { 'anonymize_ip': false });
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="/" aria-label="Go to homepage">minidump.net</a>
  </div>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about" aria-label="Read more about the author">
          <img class="sidebar-profile-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Kevin Gosse</h4>
        
          <h5 class="sidebar-profile-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/" title="Home">
    
      <i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/tags" title="Tags">
    
      <i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/archives" title="Archives">
    
      <i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/#about" title="About">
    
      <i class="sidebar-button-icon fas fa-lg fa-question" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/kookiz" target="_blank" rel="noopener" title="Twitter">
    
      <i class="sidebar-button-icon fab fa-lg fa-twitter" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/kevingosse" target="_blank" rel="noopener" title="GitHub">
    
      <i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml" title="RSS">
    
      <i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://www.buymeacoffee.com/kevingosse" target="_blank" rel="noopener" title="Buy me a coffee">
    
      <i class="sidebar-button-icon fas fa-lg fa-coffee" aria-hidden="true"></i>
      
      <span class="sidebar-button-desc">Buy me a coffee</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaIn
               ">
        <article class="post" id="top">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title">
      Using GC.KeepAlive in async methods
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time datetime="2022-09-05T00:00:00Z">
        
  
  
  
  
    September 05 2022
  

      </time>
    
    
  </div>

</div>
          
          <div class="post-content markdown">
            <div class="main-content-wrap">
              <p>Can you figure out what&rsquo;s wrong with this code?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyDelegateType myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NativeMethods.MyNativeMethod(myDelegate);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">await</span> taskCompletionSource.Task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GC.KeepAlive(myDelegate);
</span></span></code></pre></div><p>It turns out that when running in an actual application, there is a probability that <code>myDelegate</code> will get collected despite the call to <a href="https://learn.microsoft.com/en-us/dotnet/api/system.gc.keepalive?view=net-6.0&amp;WT.mc_id=DT-MVP-5003493"><code>GC.KeepAlive</code></a>.</p>
<p>This code was posted <a href="https://github.com/dotnet/runtime/issues/74966">in an issue in the dotnet/runtime repository</a>, and I followed it closely because I really couldn&rsquo;t tell what the error was. If you can&rsquo;t either, then stick around and let&rsquo;s figure out what&rsquo;s happening.</p>
<h1 id="gckeepalive">GC.KeepAlive</h1>
<p>First, let&rsquo;s remind what is <code>GC.KeepAlive</code> and why it&rsquo;s needed here.</p>
<p>As you probably already know, the GC is responsible for freeing memory when objects are not used anymore. It does so by tracking references: if there are no reachable references to a given object, then it can be cleaned away.</p>
<p>The GC is smart enough to know the exact point in a method where an object stops being referenced. For instance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> Test()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> obj = <span style="color:#66d9ef">new</span> Object();
</span></span><span style="display:flex;"><span>  DoStuffWithObj(obj);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// At this point, the GC knows the object isn&#39;t used anymore and may collect obj</span>
</span></span><span style="display:flex;"><span>  DoStuff();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As soon as <code>DoStuffWithObj</code> is called, and assuming that method doesn&rsquo;t store a reference to <code>obj</code> somewhere, the object may be garbage collected.</p>
<blockquote>
<p>Note: If you want to test this behavior, make sure to run your code in Release mode, without a debugger. In Debug mode, the lifetime of the instances is extended until the end of the scope, to make debugging easier.</p>
</blockquote>
<p>Normally, this is not something developers have to worry about. But things get trickier when you start calling native methods. Managed methods are decorated with special metadata that allows the GC to track the lifetime of the local variables. There is no such thing in native methods, so by default the GC considers that the native code does not hold any reference to managed code (doing the opposite could lead to memory leaks). From an object lifetime standpoint, calling a native method is effectively the same as calling a method with a weak reference:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Test()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obj = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">object</span>();
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(obj));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MyNativeMethod(WeakReference obj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The native method does not keep the object alive</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So what happens if the garbage collector decides to run while the native method is executing?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Test()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obj = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">object</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// As soon as MyNativeMethod is called, there are no more references to obj</span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(obj));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MyNativeMethod(WeakReference obj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The native method does not keep the object alive</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Doing stuff</span>
</span></span><span style="display:flex;"><span>    Thread.Sleep(<span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Trying to use the object</span>
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">&#34;Is alive: &#34;</span> + obj.IsAlive); <span style="color:#75715e">// Is alive: False</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we can see here, the GC might collect the object while the native method is running, which would probably cause an access violation if the native code then tries to use it.</p>
<p>Let&rsquo;s go on a little tangent and talk about why I needed to add <code>[MethodImpl(MethodImplOptions.AggressiveOptimization)]</code> to this example.</p>
<p>Since around .NET Core 3, the tiered JIT is enabled by default. Because of it, the first 30 invocations of a method use a less optimized version of the code. Incidentally, that less optimized version is not as aggressive at tracking the lifetime of objects, and the lifetime of <code>obj</code> ends up being extended until the end of the method, ruining the example. <code>[MethodImpl(MethodImplOptions.AggressiveOptimization)]</code> forces the tiered JIT to emit an optimized version of the method during the first invocation.</p>
<p>Here&rsquo;s what happens if I remove it and run the example multiple times:</p>


 
  
  
  
  
    
  
    
      
    
  

<div class="figure center" >
  
    <a class="fancybox" href="/images/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0-1.webp" data-fancybox="">
  
    <img class="fig-img" src="/images/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0-1.webp" >
  
    </a>
  
  
</div>

<p>Neat uh? The tiered JIT has been around for a few years but my mind is still blown away by the fact that a method can suddenly change its behavior through the execution of a program.</p>
<p>So, when calling a native method and giving it a reference to a managed object, the GC might collect that object at any point in time. How do we prevent that? There are multiple ways, and one of them is <code>GC.KeepAlive</code>.</p>
<p>The most counter-intuitive fact about <code>GC.KeepAlive</code> is that you don&rsquo;t put it <em>before</em> the place where you need it but <em>after</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Test()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obj = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">object</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// As soon as MyNativeMethod is called, there are no more references to obj</span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(obj));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    GC.KeepAlive(obj); <span style="color:#75715e">// Keep obj alive until this point</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MyNativeMethod(WeakReference obj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The native method does not keep the object alive</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Doing stuff</span>
</span></span><span style="display:flex;"><span>    Thread.Sleep(<span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Trying to use the object</span>
</span></span><span style="display:flex;"><span>    Console.WriteLine(<span style="color:#e6db74">&#34;Is alive: &#34;</span> + obj.IsAlive); <span style="color:#75715e">// Is alive: True</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is because <code>GC.KeepAlive</code> does not actually do anything. You can just think of it as a syntactic sugar to insert a reference to an object. We could achieve the exact same result with an empty method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Test()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> obj = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">object</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(obj));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyGCKeepAlive(obj);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.NoInlining)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MyGCKeepAlive(<span style="color:#66d9ef">object</span> obj)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Nothing</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But we have to add the <code>[MethodImpl(MethodImplOptions.NoInlining)]</code> attribute to prevent the JIT from optimizing away the empty method, which would remove our fake reference. At least with <code>GC.KeepAlive</code> you don&rsquo;t have to worry about this kind of stuff.</p>
<h1 id="gckeepalive-in-async-methods">GC.KeepAlive in async methods</h1>
<p>Now that we know what is <code>GC.KeepAlive</code> and how to use it, let&rsquo;s go back to the code that prompted this article:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>MyDelegateType myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NativeMethods.MyNativeMethod(myDelegate);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">await</span> taskCompletionSource.Task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>GC.KeepAlive(myDelegate);
</span></span></code></pre></div><p>The author of this code is trying to track the completion of an asynchronous native method. To do so, they create a delegate that will complete a <code>TaskCompletionSource</code>, then give that delegate to the native code. Assumedly, the native code will call that delegate at the end of the asynchronous operation, thus completing the TCS.</p>
<p>Because the GC can&rsquo;t track the lifetime of <code>myDelegate</code> through the invocation of <code>NativeMethods.MyNativeMethod</code>, the author of this code added a call to <code>GC.KeepAlive(myDelegate)</code> at the end of the method. Yet, the application crashed with an access violation. What&rsquo;s going on?</p>
<p>Let&rsquo;s start by making sure we can reproduce the issue. Just like before, we&rsquo;re going to use a weak reference to simulate the behavior of the native call:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task AsyncMethod()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Action myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(myDelegate));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> taskCompletionSource.Task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    GC.KeepAlive(myDelegate);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> MyNativeMethod(WeakReference myDelegate)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Simulate an asynchronous operation</span>
</span></span><span style="display:flex;"><span>    Task.Run(() =&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Do some stuff</span>
</span></span><span style="display:flex;"><span>        Thread.Sleep(<span style="color:#ae81ff">2000</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Console.WriteLine(<span style="color:#e6db74">&#34;Is alive: &#34;</span> + myDelegate.IsAlive); <span style="color:#75715e">// Is alive: False</span>
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And indeed, this code displays <code>Is alive: False</code>, meaning that the delegate got collected despite the call to <code>GC.KeepAlive</code>.</p>
<p>As hinted by the title of the article, the issue is that we&rsquo;re using <code>GC.KeepAlive</code> inside of an async method. If we rewrite the code to wait synchronously instead…</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> SyncMethod()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Action myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(myDelegate));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    taskCompletionSource.Task.Wait(); <span style="color:#75715e">// Wait synchronously on the TCS</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    GC.KeepAlive(myDelegate);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>… then the code displays <code>Is alive: True</code> as expected.</p>
<p>To explain this, we must dig a bit into how async methods work. At compilation time they are rewritten into a state machine. Our previous example would look like this (simplified) :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StateMachine</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> _state;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Action _myDelegate;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> MoveNext()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span> (_state)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span>: <span style="color:#75715e">//Initial state</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                _myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(_myDelegate));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                _state = <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Jump to the next step when the execution resume</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// Ask taskCompletionSource.Task to call MoveNext again when it completes</span>
</span></span><span style="display:flex;"><span>                taskCompletionSource.Task.GetAwaiter().OnCompleted(() =&gt; MoveNext());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">1</span>: <span style="color:#75715e">// Continuation of the &#34;await taskCompletionSource.Task&#34;</span>
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                GC.KeepAlive(_myDelegate);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Suddenly, it becomes apparent that <code>GC.KeepAlive</code> is not going to work as intended. It is on a different branch than the call to <code>MyNativeMethod</code>, and it&rsquo;s just going to reference an object that the state machine is already referencing anyway. But then why isn&rsquo;t our state machine keeping <code>myDelegate</code> alive?</p>
<p>To understand that, let&rsquo;s walk the reference chain. <code>myDelegate</code> is referenced by the async state machine. The async state machine is referenced by the task continuation (implicitly created when calling <code>await taskCompletionSource.Task;</code>). The task continuation is referenced by the <code>TaskCompletionSource</code>. And the <code>TaskCompletionSource</code> is referenced by… nobody once the method exits.</p>
<p>Put in other words, when calling a synchronous method, the caller is responsible for continuing the workflow once the callee returns. When calling an asynchronous method, the responsibility is inverted: the caller returns, and the callee must call the continuation once the asynchronous operation is completed. But since the callee is a native method, it is not capable of keeping the managed reference alive.</p>
<p>The fix here is to allocate a GC handle to keep the reference alive:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[MethodImpl(MethodImplOptions.AggressiveOptimization)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">async</span> Task AsyncMethod()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Run a garbage collection in 1 second</span>
</span></span><span style="display:flex;"><span>    Task.Delay(<span style="color:#ae81ff">1000</span>).ContinueWith(_ =&gt; { GC.Collect(); });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> taskCompletionSource = <span style="color:#66d9ef">new</span> TaskCompletionSource();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Action myDelegate = () =&gt; taskCompletionSource.SetResult();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> handle = GCHandle.Alloc(myDelegate);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MyNativeMethod(<span style="color:#66d9ef">new</span> WeakReference(myDelegate));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> taskCompletionSource.Task;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    handle.Free();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can think of the GC handle as a special reference that will always stay alive until <code>Free()</code> is called. The GC handle is going to keep the delegate alive, which references the <code>TaskCompletionSource</code>, which references the task continuation, which references the async state machine. And so the object graph is preserved until the end of the asynchronous operation.</p>
<h1 id="is-this-a-bug">Is this a bug?</h1>
<p>Honestly, I&rsquo;m conflicted. The behavior makes perfect sense once you look at what&rsquo;s happening under the hood. But even with a good knowledge of how <code>async</code> works in C#, I&rsquo;m fairly sure that I would have made the same mistake if I had to write this code. In fact, it&rsquo;s only after Stephen Toub commented in the github issue that I realized why the code was failing. On the other hand, adding special support for <code>GC.KeepAlive</code> in async methods would require a significant amount of work for something that is rarely used, so it&rsquo;s probably not worth the trouble. Maybe adding a warning when <code>GC.KeepAlive</code> is used in an async method could be a good middle ground.</p>

              


            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/dotnet/">dotnet</a>

  <a class="tag tag--primary tag--small" href="/tags/async/">async</a>

                  </div>
                
              
            
            
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/writing-a-net-profiler-in-c-part-2-8039da001e43/" data-tooltip="Writing a .NET profiler in C#  —  Part 2" aria-label="NEXT: Writing a .NET profiler in C#  —  Part 2">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/c-why-function-pointers-cant-be-used-on-instance-methods-8a99fc99b040/" data-tooltip="Why function pointers can&#39;t be used on instance methods in C#" aria-label="PREVIOUS: Why function pointers can&#39;t be used on instance methods in C#">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


            

<link href="https://fonts.googleapis.com/css?family=Cookie&amp;display=swap" rel="stylesheet">
<div class="bmc-btn-container"><a class="bmc-btn" target="_blank" href="https://buymeacoffee.com/kevingosse">☕<span class="bmc-btn-text">Enjoyed the article? Buy me a coffee</span></a></div>

<style>
    .bmc-btn {
        min-width: 210px;
        color: #000000;
        background-color: #FFFFFF !important;
        height: 60px;
        border-radius: 12px;
        font-size: 28px;
        font-weight: Normal;
        border: none;
        line-height: 27px;
        text-decoration: none !important;
        display: inline-flex !important;
        justify-content: center;
        align-items: center;
        font-family: 'Cookie', cursive !important;
        -webkit-box-sizing: border-box !important;
        box-sizing: border-box !important;
    }

    .bmc-btn:hover, .bmc-btn:active, .bmc-btn:focus {
        text-decoration: none !important;
        cursor: pointer;
    }

    .bmc-btn-text {
        margin-left: 8px;
        display: inline-block;
        line-height: 0;
        width: 100%;
        flex-shrink: 0;
        font-family: [FONT] !important;
    }

    .logo-outline {
        fill: #000000;
    }

    .logo-coffee {
        fill: #ffffff;
    }</style>

  
<div id="utterances">
      <noscript>Please enable JavaScript to view the comments powered by Utterances.</noscript>
    </div>
<script src="https://utteranc.es/client.js"
        repo="kevingosse/kevingosse.github.io"
        issue-term="title"
        label="comments"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
  


          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2024 Kevin Gosse. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        
<div class="post-actions-wrap">
  <nav >
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/writing-a-net-profiler-in-c-part-2-8039da001e43/" data-tooltip="Writing a .NET profiler in C#  —  Part 2" aria-label="NEXT: Writing a .NET profiler in C#  —  Part 2">
          
              <i class="fa fa-angle-left"></i>
              <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
            </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/c-why-function-pointers-cant-be-used-on-instance-methods-8a99fc99b040/" data-tooltip="Why function pointers can&#39;t be used on instance methods in C#" aria-label="PREVIOUS: Why function pointers can&#39;t be used on instance methods in C#">
          
              <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
              <i class="fa fa-angle-right"></i>
            </a>
        </li>
      
    </ul>
  </nav>
<ul class="post-actions post-action-share" >
  
    <li class="post-action hide-lg hide-md hide-sm">
      <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
        <i class="fa fa-share-alt" aria-hidden="true"></i>
      </a>
    </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Twitter" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Linkedin" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.reddit.com/submit?url=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Reddit" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i>
        </a>
      </li>
    
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://news.ycombinator.com/submitlink?u=https://minidump.net/c-using-gc-keepalive-in-async-methods-8d20fd79f0a0/" title="Share on Hacker News" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i>
        </a>
      </li>
    
  
  
  <li class="post-action">
    
      <a class="post-action-btn btn btn--default" href="#top" aria-label="Back to top">
      <i class="fa fa-arrow-up" aria-hidden="true"></i>
    
    </a>
  </li>
</ul>
</div>


      </div>
      
<div id="share-options-bar" class="share-options-bar" data-behavior="2">
  <i id="btn-close-shareoptions" class="fa fa-times"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fminidump.net%2Fc-using-gc-keepalive-in-async-methods-8d20fd79f0a0%2F" aria-label="Share on Twitter">
          <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.linkedin.com/feed/?shareActive=true&amp;text=https%3A%2F%2Fminidump.net%2Fc-using-gc-keepalive-in-async-methods-8d20fd79f0a0%2F" aria-label="Share on Linkedin">
          <i class="fab fa-linkedin" aria-hidden="true"></i><span>Share on Linkedin</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.reddit.com/submit?url=https%3A%2F%2Fminidump.net%2Fc-using-gc-keepalive-in-async-methods-8d20fd79f0a0%2F" aria-label="Share on Reddit">
          <i class="fab fa-reddit" aria-hidden="true"></i><span>Share on Reddit</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fminidump.net%2Fc-using-gc-keepalive-in-async-methods-8d20fd79f0a0%2F" aria-label="Share on Hacker News">
          <i class="fab fa-hacker-news" aria-hidden="true"></i><span>Share on Hacker News</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>


    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-times"></i>
    </div>
    
      <img id="about-card-picture" src="https://minidump.net/images/profile.png" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Kevin Gosse</h4>
    
      <div id="about-card-bio">Kevin Gosse has been using Microsoft .NET technologies for more than 15 years, across client, server, and mobile applications. Passionate about debugging. He is Microsoft MVP and is currently employed at Datadog, where he works on the performance of the .NET APM.</div>
    
    
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://minidump.net/images/code.png');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js" integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script src="https://minidump.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>




    
  </body>
</html>

